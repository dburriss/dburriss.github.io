<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>Reliability with Intents</title><meta name="description" content="In this post I explore a solution for sending messages across process boundaries where the notification needs to be transactional with state change"><meta name="author" content="Devon Burriss"><meta itemprop="name" content="Reliability with Intents"><meta itemprop="description" content="In this post I explore a solution for sending messages across process boundaries where the notification needs to be transactional with state change"><meta itemprop="image" content="https://devonburriss.me/img/posts/2019/target-500.jpg"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="Reliability with Intents"><meta name="twitter:description" content="In this post I explore a solution for sending messages across process boundaries where the notification needs to be transactional with state change"><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/posts/2019/target-500.jpg"><meta property="og:title" content="Reliability with Intents"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/reliability-with-intents/"><meta property="og:image" content="https://devonburriss.me/img/posts/2019/target-500.jpg"><meta property="og:description" content="In this post I explore a solution for sending messages across process boundaries where the notification needs to be transactional with state change"><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script><script type="module" src="/js/search-ui.js"></script></head><body><header class="site-header"><nav class="site-nav"><a class="site-title nav-badge" href="/">DEVON BURRISS</a><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/notes/">Notes</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><span style="display:contents"><header class="page-header"><h1>Reliability with Intents</h1><p class="page-subtitle">Telling the world about state changes</p><p class="post-meta">Devon Burriss</p></header><div class="topic-pills"><a class="topic-pill" href="/topics/engineering-practices/" title="How we build, test, and validate software.">Engineering Practices</a><a class="topic-pill" href="/topics/platforms-runtime/" title="Runtimes and execution environments (not frameworks).">Platforms &amp; Runtime</a><a class="topic-pill" href="/topics/software-design/" title="Architecture, design, modeling, and distributed systems.">Software Design</a></div><hr></span><article class="prose"><p>If you are using any kind of messaging architecture to notify outside of your system of internal changes you may have noticed a reliability problem. Unless you are using distributed transactions to ensure atomic operations you may have noticed an ordering problem in updating state and notifying the rest of the world. In this post, I will look at this problem and a possible solution.</p>
<!--more-->
<blockquote>
<p>This post is part of <a href="https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/">#FsAdvent 2019</a>. PS. THIS IS NOT PRODUCTION WORTHY CODE! FOR DEMO PURPOSES ONLY!</p>
</blockquote>
<blockquote>
<p>UPDATE: Posting this on Twitter yielded that I had, as I expected, uncovered an existing pattern. With the example I show here it is basically the Transactional outbox. I will say that the pattern I show here can function more like a local orchestrator that forms part of an choreography-based saga.</p>
</blockquote>
<h2 id="the-atomic-problem">The atomic problem</h2>
<p>Oft times when doing an operation in an application, I see a call to put some kind of message on a queue (or topic) to notify other systems that this event occurred.</p>
<pre><code class="language-fsharp">// save to database
// it could then fail
// put on queue
person
|&gt; Data.createPerson dbConnection None
|&gt; tap (fun _ -&gt; failwith &quot;Failed before sending message&quot;) // &lt;-- simulate application crash
|&gt; Result.bind (Message.personCreated queue)
</code></pre>
<p>What happens though if the application crashes right after saving some changes to the database? Your application has changed state but has not, and will not, notify the rest of the world about that change. What if other business processes rely on this?</p>
<p><img src="/img/posts/2019/intents-1.png" alt="persist state then send" /></p>
<blockquote>
<p>If you are thinking that the chances of this happening are vanishingly small, let me float this idea. A 99.99% uptime still means almost an hour of downtime a year. On a high load system in the cloud (chaos monkey as a service), systems can disappear more often than you think.</p>
</blockquote>
<p>I have seen businesses be unaware of this communication loss for months, where the result is customer service calls routed to teams dependent on that message. The problem here is both assume every message is sent, never considering the loss. Only once these numbers were monitored did the problem become apparent.</p>
<p>So back to the problem. Of course, reversing the order does not help.</p>
<p><img src="/img/posts/2019/intents-2.png" alt="send then persist state" /></p>
<p>Now you are notifying the world about a change that never happened.</p>
<h2 id="what-is-your-intention">What is your intention?</h2>
<p>I will mention a few more sophisticated variations in the conclusion but the solution is fairly simple. Separate the intention of sending the notification from the actual sending.</p>
<p>F# discriminated unions give a nice way to define our intention, as it is a state machine.</p>
<pre><code class="language-fsharp">// domain type
type Person = {
 id:string
 name:string
 email:string
}

// Here the type of case could be the entity, command, or the message to be sent. 
// Whatever makes the most sense.
type IntentOfPersonCreated = 
| Pending of Person
| Complete of Person
</code></pre>
<p>We can then save the intention to send the message in a transaction with the state change that is prompting the notification.</p>
<pre><code class="language-fsharp">// save to database with intent
// intent puts on queue
use transaction = dbConnection.BeginTransaction()
let txn = Some transaction

person 
|&gt; Data.createPerson dbConnection txn
|&gt; Result.map (fun p -&gt; Data.createPersonIntent dbConnection txn (Pending p))

transaction.Commit()
</code></pre>
<p>Don't get too hung up on what this code is doing. The important part here is that <code>createPerson</code> and <code>createPersonIntent</code> are both called using the same transaction.</p>
<p>Finally, you need to process all persisted intents.</p>
<pre><code class="language-fsharp">let handleIntent connection queue (id,intent) =
    // handle each state of the intent
    match intent with
    | Pending person -&gt; 
        Message.personCreated queue person |&gt; ignore
        Data.markCreatePersonIntentDone connection id (Complete person) |&gt; ignore
        printfn &quot;%A intent sent&quot; person
    | Complete _ -&gt; failwith &quot;These should not be queried&quot;
 

let processIntents (dbConnection:DbConnection) queue =
    let intentsR = Data.getCreatePersonIntents dbConnection
    match intentsR with
    | Error ex -&gt; raise ex
    | Ok intents -&gt; intents |&gt; Seq.iter (handleIntent dbConnection queue)
</code></pre>
<p>Note the state changes in <code>handleIntent</code> where the message is sent and the new state of the <strong>intent</strong> is persisted back. If you expanded the states that these can land in, you could potentially move through multiple states. This would allow for a kind of local orchestrator, in a choreography-based saga.</p>
<p>Now as long as you have a process that is regularly running through and processing the <strong>intents</strong>, you can guarantee that as soon as all infrastructure is healthy, all notifications will be sent at least once.</p>
<p><img src="/img/posts/2019/intents-3.png" alt="transactional persistence of state and intention" /></p>
<h2 id="implementation-ideas">Implementation ideas</h2>
<p>All the DEMO code is <a href="https://github.com/dburriss/intent-blog">available on my GitHub</a> but I wanted to talk about a few implementation details and what you may want to do differently.</p>
<p>This is the table I am storing the <strong>intents</strong> in.</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS intents (
 id INTEGER PRIMARY KEY AUTOINCREMENT,
 iscomplete INTEGER NOT NULL DEFAULT 0,
 intenttype TEXT NOT NULL,
 intent BLOB NOT NULL
);
</code></pre>
<ul>
<li>I am using <code>iscomplete</code> to filter out the <strong>intents</strong> I no longer need to process.</li>
<li><code>intenttype</code> allows me to use this table for multiple <strong>intents</strong> and treat each differently.</li>
<li><code>intent</code> is a JSON string of the serialized <strong>intent</strong>.</li>
</ul>
<p>For production, you will likely want to add some indexes. Another thought I had was a partition key that could be used to process the intents from multiple consumers. This way you could scale out consumers even if the order was important for related <strong>intents</strong>, with a consumer per partition key.</p>
<p>You can check out the usage of this on the <a href="https://github.com/dburriss/intent-blog">GitHub</a> repository, specifically <code>Data.fs</code> but the following code should give a sufficient peek under the hood to get you going.</p>
<pre><code class="language-fsharp">let createIntent (connection:#DbConnection) (transaction:#DbTransaction option) (intent:string) (type':string)=
    let data = [(&quot;@intent&quot;,box intent);(&quot;@intenttype&quot;,box type')] |&gt; dict |&gt; fun d -&gt; DynamicParameters(d)
    let sql = &quot;INSERT INTO intents (intent,intenttype) VALUES (@intent,@intenttype);&quot;
    execute connection sql data transaction

let createPersonIntent (connection:#DbConnection) (transaction:#DbTransaction option) (intent:IntentOfPersonCreated) =
    let intent' = intent |&gt; JsonConvert.SerializeObject
    createIntent connection transaction intent' &quot;create-person&quot;
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Of course, increasing the reliability of your system comes at the cost of a bit of added complexity, as well as a latency penalty for the outgoing notifications. I will say that on top of the reliability increase, you also get a fairly good audit log without having moved to Event Sourcing (no I am not saying auditing alone is a good reason to do ES).</p>
<p>Another useful design choice that is related here is collecting events as your code executes. If you are using a functional style of programming, always returning events is the way to go. If you are using a more imperative style using classic DDD techniques, an aggregate root is a good place to accumulate these events. Erik Heemskerk and myself worked together and he has a great <a href="https://www.erikheemskerk.nl/ddd-persistence-recorded-event-driven-persistence/">post describing this technique</a>.</p>
<p>I did want to acknowledge that the processing of the intents does have some challenges that I have not covered in this post. You want to try to avoid having multiple workers pulling the same kind of <strong>intents</strong> or the number of duplicate messages will explode. Since EXACTLY ONCE message delivery using a push mechanism is a pipe dream, you need to cater for duplicate messages. Having a single instance processing means it can easily go down, so monitoring and restarts are important for the health of your system. A product like <a href="https://www.hangfire.io/">Hangfire</a> may be useful here, or scheduled serverless functions. Your mileage may vary.</p>
<p>Finally, I did want to also point out a <a href="https://www.youtube.com/watch?v=FkDZw9HmwQY&amp;list=FLtCKfk3-Xz9K1kCkvT_v6aQ">great talk of Erik's</a> where he talks about turning this around so consumers come get the events from you. If you want to send out notifications you can write the consumer of your event feed that then notifies&hellip; or just tell people to come and fetch and be done with all this headache.</p>
<h2 id="resources">Resources</h2>
<ol>
<li><a href="https://microservices.io/patterns/data/saga.html">Saga pattern</a></li>
<li><a href="https://microservices.io/patterns/data/transactional-outbox.html">Transactional Outbox</a></li>
</ol>
<h2 id="credits">Credits</h2>
<ul>
<li>Photo by Jens Lelie on <a href="https://unsplash.com/photos/u0vgcIOQG08">Unsplash</a></li>
</ul>
</article><hr><nav class="pager"><ul class="pager-links"><li><a href="/converting-fsharp-csharp/" title="Converting between F# and C# types">← Previous</a></li><li><a href="/canopy-from-fsx/" title="Canopy from a FSX Script">Next →</a></li></ul></nav></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><div class="comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'devonburriss';(function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'https://devonburriss.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>