<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>3 tips for more maintainable unit tests</title><meta name="description" content="Highlights some tips for making tests more resilient by focusing on behavior rather than structure. By testing from the outside we are free to change implementation details."><meta name="author" content="Devon Burriss"><meta itemprop="name" content="3 tips for more maintainable unit tests"><meta itemprop="description" content="Highlights some tips for making tests more resilient by focusing on behavior rather than structure. By testing from the outside we are free to change implementation details."><meta itemprop="image" content="https://devonburriss.me/img/posts/2018/bridge-cables-500.jpg"><link rel="canonical" href="https://devonburriss.me/maintainable-unit-tests/"><meta itemprop="datePublished" content="2018-04-07" id="date"><meta itemprop="dateModified" content="2018-04-07" id="mdate"><meta itemprop="headline" content="3 tips for more maintainable unit tests - Avoid having to fix dozens of tests every time you make a significant code change"><meta itemprop="mainEntityOfPage" content="https://devonburriss.me/maintainable-unit-tests/"><meta name="headline" content="3 tips for more maintainable unit tests - Avoid having to fix dozens of tests every time you make a significant code change"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="3 tips for more maintainable unit tests"><meta name="twitter:description" content="Highlights some tips for making tests more resilient by focusing on behavior rather than structure. By testing from the outside we are free to change implementation details."><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/posts/2018/bridge-cables-500.jpg"><meta property="og:title" content="3 tips for more maintainable unit tests"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/maintainable-unit-tests/"><meta property="og:image" content="https://devonburriss.me/img/posts/2018/bridge-cables-500.jpg"><meta property="og:description" content="Highlights some tips for making tests more resilient by focusing on behavior rather than structure. By testing from the outside we are free to change implementation details."><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script><script type="module" src="/js/search-ui.js"></script></head><body><header class="site-header"><nav class="site-nav"><a class="site-title nav-badge" href="/">DEVON BURRISS</a><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/notes/">Notes</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><span style="display:contents"><header class="page-header"><h1>3 tips for more maintainable unit tests</h1><p class="page-subtitle">Avoid having to fix dozens of tests every time you make a significant code change</p><p class="post-meta">Devon Burriss &#183; Apr 07, 2018</p></header><div class="topic-pills"><a class="topic-pill" href="/topics/engineering-practices/" title="How we build, test, and validate software.">Engineering Practices</a></div><hr></span><article class="prose"><p>Although having a good collection of unit tests makes you feel safe and free to refactor, a bad collection of tests can make you scared to refactor. How so? A single change to application code can cause a cascade of failing tests. Here are some tips for avoiding (or fighting back) from that situation.</p>
<!--more-->
<blockquote>
<p>Important! This post contains example code. Don't copy/paste into production code.</p>
</blockquote>
<h2 id="tip-1-test-behavior-not-structure">Tip 1: Test behavior not structure</h2>
<p>The behavior of the system is what the business cares about and it is what you should care about as well from a verification point of view. If requirements change drastically then changes to the system are expected, including the tests. The promise of good unit test coverage is that you can refactor with confidence that your tests will catch any regressions in behavior. However if you are testing the structure of your application rather than the behavior, refactoring will be difficult since you want to change the structure of your code but your tests are asserting that structure! Worse, your test suite might not even test the behavior but you have confidence in them because of the sheer volume of structural tests.</p>
<p>If you test the behavior of the system from the outside you are free to change implementation and your tests remain valid. I am not necessarily talking about integration style tests but actual unit tests whose entry point is a natural boundary. At work we have use-case classes that form this natural entry-point into any functionality.</p>
<p>So let's look at an example of structural testing, and see the what happens when we try make a change to the implementation details. As an example we have a test against a <code>CreatePerson</code> use-case that creates a <code>Person</code> class and persists it if it is a valid person object. The initial design takes in an <code>IValidator</code> to determine whether the person is valid.</p>
<pre><code class="language-csharp">// tests
// test for invalid name omitted...

[Fact]
public void CreatingPerson_WithValidPerson_CallsIsValid()
{
    var name = &quot;Bob&quot;;
    var people = Substitute.For&lt;IPersonRepository&gt;();
    var validator = Substitute.For&lt;IPersonValidator&gt;();
    var createPerson = new CreatePerson(people, validator);

    createPerson.With(name);

    validator.ReceivedWithAnyArgs(1).IsValid(Arg.Any&lt;Person&gt;());
}

// anemic domain entity
public class Person
{
    public Person(Guid id, string name)
    {
        Id = id;
        Name = name;
    }

    public Guid Id { get; set; }
    public string Name { get; set; }
}

// use-case
public class CreatePerson
{
    private readonly IPersonRepository personRepository;
    private readonly IPersonValidator personValidator;

    public CreatePerson(IPersonRepository personRepository, IPersonValidator personValidator)
    {
        this.personRepository = personRepository;
        this.personValidator = personValidator;
    }

    public void With(string name)
    {
        var person = new Person(Guid.NewGuid(), name);
        if (personValidator.IsValid(person))
        {
            personRepository.Create(person);
        }
        else
        {
            throw new ArgumentException(nameof(name));
        }
    }
}
</code></pre>
<p>Notice how we are asserting against a dependency (<code>IValidator</code>) of the use-case (<code>CreatePerson</code>). Our test has structural knowledge of how <code>CreatePerson</code> is implemented. Let's see what happens when we want to refactor this code&hellip;</p>
<p>Your team has been trying to bring in some new practices like Domain-Driven Design. The team discussed it and the <code>Person</code> class represents an easy start learning. You have been tasked with pulling behavior into the the <code>Person</code> entity and make it less anemic.</p>
<p>As a first try you move the validation logic into the <code>Person</code> class.</p>
<pre><code class="language-csharp">public class Person
{
    public Person(Guid id, string name)
    {
        Id = id;
        Name = name;
    }

    public bool IsValid()
    {
        if (Id == Guid.Empty) return false;
        if (string.IsNullOrEmpty(Name)) return false;
        return true;
    }

    public Guid Id { get; }
    public string Name { get; }
}
</code></pre>
<p>Looking at the use-case, we no longer need to inject <code>IValidator</code>. Not only is what we test going to have to change, we are going to have to change the test completely because we no longer have a validator to inject as a mock. We have seen the first signs of our tests being fragile.</p>
<p>Let's try make our test focus on the behavior we expect instead of relying on the structure of our code.</p>
<pre><code class="language-csharp">// test for invalid name omitted...
[Fact]
public void CreatePerson_WithValidName_PersistsPerson()
{
    var name = &quot;Bob&quot;;
    InMemoryPersonRepository people = Given.People;
    var createPerson = new CreatePerson(people);

    createPerson.With(name);

    Assert.Equal(name, people.All().First().Name);
}
</code></pre>
<p>Don't worry too much about <code>InMemoryPersonRepository people = Given.People;</code> for now, we will come back to it. All you need to know is that <code>InMemoryPersonRepository</code> implements <code>IPersonRepository</code>.</p>
<p>Since we no longer need <code>IValidator</code> and it's implementation, we delete those. We also get to delete the test <code>CreatingPerson_WithValidPerson_CallsIsValid</code> as we have a better test now <code>CreatePerson_WithValidName_PersistsPerson</code> that asserts the behavior we care about, the use-case creating and persisting a new person. Yay, less test code, better coverage!</p>
<p>At this point you might be saying &ldquo;Wait! Unit tests are supposed to test one method, on one class&rdquo;. No! A unit is whatever you need it to be. I am by no means saying write no tests for your small implementation details, just make sure you are comfortable deleting them if things change. With our focus on behavior tests we can delete those detailed tests freely and still be covered. In-fact, I often just delete the tests after I am done developing the component as I just used TDD for fast feedback loop on the design and implementation. Remember that test code is still code that needs maintenance so the more coverage for less the better.</p>
<p>So back to the code. What does our use-case look like now?</p>
<pre><code class="language-csharp">public class CreatePerson
{
    private readonly IPersonRepository personRepository;
    public CreatePerson(IPersonRepository personRepository)
    {
        this.personRepository = personRepository;
    }

    public void With(string name)
    {
        var person = new Person(Guid.NewGuid(), name);
        if (person.IsValid())
        {
            personRepository.Create(person);
        }
        else
        {
            throw new ArgumentException(nameof(name));
        }
    }
}
</code></pre>
<p>Thats ok. We got rid of a dependency and moved some logic to our <code>Person</code> entity but we can do better. On reviewing your pull request someone in the team pointed out something important. You should be aiming to make unrepresentable states unrepresentable. The business doesn't allow saving a person without a name so let's make it so that we can't create an invalid <code>Person</code>.</p>
<pre><code class="language-csharp">// person entity
public class Person
{
    public Person(Guid id, string name)
    {
        if (id == Guid.Empty) throw new ArgumentException(nameof(id));
        if (string.IsNullOrEmpty(name)) throw new ArgumentException(nameof(name));

        Id = id;
        Name = name;
    }

    public Guid Id { get; }
    public string Name { get; }
}
// use-case
public class CreatePerson
{
    private readonly IPersonRepository personRepository;
    public CreatePerson(IPersonRepository personRepository)
    {
        this.personRepository = personRepository;
    }

    public void With(string name)
    {
        var person = new Person(Guid.NewGuid(), name);
        personRepository.Create(person);
    }
}
</code></pre>
<p>Look at that! We refactored the implementation without having to update our test. It still passes without any changes.</p>
<p>This was a contrived example to illustrate the point but I hope this tip helps you write more maintainable tests.</p>
<h2 id="tips-2-use-in-memory-dependencies">Tips 2: Use in-memory dependencies</h2>
<p>You have already seen <code>InMemoryPersonRepository</code> so this tip should be less verbose to explain. The claim is simply that the maintainability of your tests can be increased by using in-memory versions of your dependencies a little more and using mocking frameworks a little less.</p>
<p>I find in-memory versions of something like a repository that speaks to a database preferable to mocking frameworks for a few reasons:</p>
<ol>
<li>They tend to be easier to update than a mocking framework, especially if creation of the mocks is done in every test or fixture</li>
<li>Coupled with some tooling (see next tip) they lead to far easier setup and readability</li>
<li>They are simple to understand</li>
<li>Great debugging tool</li>
</ol>
<p>On the down side, they do take a little time to create.</p>
<p>Let's take a quick look at what the one looks like for our code so far:</p>
<pre><code class="language-csharp">public class InMemoryPersonRepository : IPersonRepository
{
    private IDictionary&lt;Guid, Person&gt; data;

    public InMemoryPersonRepository(IDictionary&lt;Guid, Person&gt; data)
    {
        this.data = data;
    }

    public IReadOnlyCollection&lt;Person&gt; All()
    {
        return new List&lt;Person&gt;(data.Values);
    }

    public void Create(Person person)
    {
        data.Add(person.Id, person);
    }
}
</code></pre>
<p>Super simple! Put in the work and give it a try, it may not be as sexy as a mocking framework but it really will help make your test suite more manageable.</p>
<h2 id="tip-3-build-up-test-tooling">Tip 3: Build up test tooling</h2>
<p>Test tooling in this context means utility classes to make readability and maintainability of the tests easier. A big part of this is about making your tests clear about the setup while still keeping it concise.</p>
<p>Let's discuss a few helpers you should have in any project&hellip;</p>
<h3 id="in-memory-dependencies">In-memory dependencies</h3>
<p>This was already discussed above. I can't stress enough how much this improves maintenance and simplifies reasoning about tests.</p>
<h3 id="builders">Builders</h3>
<p>Builders can be used as an easy way to setup test data. They are a great way of simultaneously avoiding dozens of different setup methods for your tests and a way to make it clear what the actual setup of your test is without diving into some setup method that looks like all the other setup methods.</p>
<pre><code class="language-csharp">public class InMemoryPersonRepositoryBuilder
{
    IDictionary&lt;Guid, Person&gt; data = new Dictionary&lt;Guid, Person&gt;();
    
    public InMemoryPersonRepositoryBuilder With(params PersonBuilder[] people)
    {
        foreach (Person p in people)
        {
            data.Add(p.Id, p);
        }
        return this;
    }

    public InMemoryPersonRepository Build()
    {
        return new InMemoryPersonRepository(data);
    }

    public static implicit operator InMemoryPersonRepository(InMemoryPersonRepositoryBuilder builder)
        =&gt; builder.Build();
}
</code></pre>
<p>A little trick is to put an <code>implicit</code> conversion to the class you are building up. Also take a look at <a href="https://github.com/nrjohnstone/Fluency">Fluency</a> for helping with the creation of builders.</p>
<p>A final note on this point. Just because I use builders a lot does not mean I completely throw mocking frameworks out the window. I just tend to use mocking frameworks for things I really don't care about and really aren't likely to change. I also tend to use them within other builders rather than directly in tests. This gives way more control over the grammar that you use to setup your tests.</p>
<h3 id="accessors">Accessors</h3>
<p>Not sure what else to call these but it is useful to have a static class that makes access to builders and other types you would use in setup simple. Typically I have <code>Given</code> and <code>A</code>.</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// Handles creation of instances useful to testing like entites, value objects, settings, etc.
/// &lt;/summary&gt;
public static class A
{
    public static PersonBuilder Person =&gt; new PersonBuilder();
}

/// &lt;summary&gt;
/// Handles the creation of builders that build external services for testing
/// &lt;/summary&gt;
public static class Given
{
    public static InMemoryPersonRepositoryBuilder People =&gt; new InMemoryPersonRepositoryBuilder();
}
</code></pre>
<p>This allows me to write some very concise setup code. For example if I needed to populate my person repository with 3 random people I could do so like this:</p>
<pre><code class="language-csharp">InMemoryPersonRepository people = Given.People.With(A.Person, A.Person, A.Person);
// if i wanted another with a specific name
people.Create(A.Person.With(name: &quot;Bob&quot;));
</code></pre>
<p>For completeness the <code>PersonBuilder</code> implementation:</p>
<pre><code class="language-csharp">public class PersonBuilder
{
    private Guid id;
    private string name;

    public PersonBuilder()
    {
        id = Guid.NewGuid();
        name = $&quot;name {Guid.NewGuid()}&quot;;
    }

    public PersonBuilder With(Guid id)
    {
        this.id = id;
        return this;
    }

    public PersonBuilder With(string name)
    {
        this.name = name;
        return this;
    }

    public Person Build()
    {
        return new Person(id, name);
    }

    public static implicit operator Person(PersonBuilder builder) =&gt; builder.Build();
}
</code></pre>
<h2 id="wrapping-up">Wrapping up</h2>
<p>So those are my 3 tips for making your tests more maintainable. I encourage you to give them a try. Without investing in the maintainability of your tests they can quickly become a burden rather than a boon. I have seen the practices above improve things not only in my teams but other colleagues have converged on similar learnings with the same positive results. Let me know if you find this helpful, or even if there are any points you strongly disagree with. I would love to discuss in the comments. Happy coding!</p>
</article><hr><nav class="pager"><ul class="pager-links"><li><a href="/managing-code-complexity/" title="Managing Code Complexity">← Previous</a></li><li><a href="/leader-archetypes/" title="Leader Archetypes">Next →</a></li></ul></nav></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><div class="comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'devonburriss';(function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'https://devonburriss.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>