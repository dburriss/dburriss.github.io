<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>Untitled</title><meta name="description" content="Mostly explorations in code"><meta name="author" content="Devon Burriss"><meta itemprop="name" content="Untitled"><meta itemprop="description" content="Mostly explorations in code"><meta itemprop="image" content="https://devonburriss.me/img/explore-590.jpg"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="Untitled"><meta name="twitter:description" content="Mostly explorations in code"><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/explore-590.jpg"><meta property="og:title" content="Untitled"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/ARCHITECTURE.html"><meta property="og:image" content="https://devonburriss.me/img/explore-590.jpg"><meta property="og:description" content="Mostly explorations in code"><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script><script type="module" src="/js/search-ui.js"></script></head><body><header class="site-header"><nav class="site-nav"><a class="site-title nav-badge" href="/">DEVON BURRISS</a><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/notes/">Notes</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><header class="page-header"><h1>Untitled</h1></header><article class="prose"><h1 id="site-renderer-architecture">Site Renderer Architecture</h1>
<h2 id="overview">Overview</h2>
<p>This document describes the architecture of the SiteRenderer static site generator, with a focus on the <strong>Option 3: Deferred HTML Generation</strong> architecture that was implemented to solve wiki link resolution timing issues.</p>
<h2 id="background-the-wiki-link-resolution-problem">Background: The Wiki Link Resolution Problem</h2>
<p>The original architecture had a fundamental timing issue:</p>
<ol>
<li><strong>HTML Generation (early)</strong>: Content was converted to HTML immediately upon loading</li>
<li><strong>Link Resolution (late)</strong>: Wiki link resolution data was built after HTML generation</li>
<li><strong>Result</strong>: Wiki links couldn't be resolved because the HTML was already generated</li>
</ol>
<p>This led to wiki links like <code>[[Token]]</code> being rendered as <code>&lt;span class=&quot;unresolved-link&quot;&gt;Token&lt;/span&gt;</code> instead of proper <code>&lt;a href=&quot;/notes/token/&quot;&gt;Token&lt;/a&gt;</code> links, even when the target content existed.</p>
<h2 id="option-3-deferred-html-generation-architecture">Option 3: Deferred HTML Generation Architecture</h2>
<p>The new architecture separates content loading from HTML generation, allowing wiki links to be resolved during rendering.</p>
<h3 id="core-principles">Core Principles</h3>
<ol>
<li><strong>Deferred Rendering</strong>: HTML is not generated until all content is loaded and indexed</li>
<li><strong>Resolution Context</strong>: A comprehensive lookup table is built before any HTML generation</li>
<li><strong>Context-Aware Pipeline</strong>: The Markdig pipeline receives resolution data during rendering</li>
<li><strong>Single Pass</strong>: HTML is generated once with full context, avoiding re-processing</li>
</ol>
<h3 id="data-flow">Data Flow</h3>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│ Phase 1: Raw Content Loading                                │
│ ├─ loadRawPosts: Load markdown + metadata (no HTML)         │
│ ├─ loadRawPages: Load markdown + metadata (no HTML)         │
│ └─ loadRawNotes: Load markdown + metadata (no HTML)         │
├─────────────────────────────────────────────────────────────┤
│ Phase 2: Build Resolution Context                           │
│ └─ buildResolutionContext: Create title → path mappings     │
│     ├─ TitleLookup: normalized title → RawContentItem list  │
│     └─ PathLookup: normalized title → output path           │
├─────────────────────────────────────────────────────────────┤
│ Phase 3: Render with Context                                │
│ └─ renderContentItem: For each raw item                     │
│     ├─ Pass ResolutionContext to Markdig pipeline          │
│     ├─ WikiLinkExtension resolves [[links]] in real-time   │
│     └─ Generate final HTML with resolved links             │
├─────────────────────────────────────────────────────────────┤
│ Phase 4: Site Generation                                    │
│ └─ Standard site generation with rendered content           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="key-components">Key Components</h2>
<h3 id="data-models">Data Models</h3>
<h4 id="rawcontentitem">RawContentItem</h4>
<p>Stores content before HTML generation:</p>
<pre><code class="language-fsharp">type RawContentItem = {
    SourcePath: string      // Original file path
    Markdown: string        // Raw markdown content
    Meta: FrontMatter      // Parsed frontmatter
    Kind: string           // &quot;post&quot;, &quot;page&quot;, or &quot;note&quot;
}
</code></pre>
<h4 id="resolutioncontext">ResolutionContext</h4>
<p>Provides lookup tables for wiki link resolution:</p>
<pre><code class="language-fsharp">type ResolutionContext = {
    TitleLookup: Map&lt;string, RawContentItem list&gt;  // normalized title → items
    PathLookup: Map&lt;string, string&gt;                // normalized title → URL path
}
</code></pre>
<h4 id="renderedcontentitem">RenderedContentItem</h4>
<p>Final rendered content with resolved links:</p>
<pre><code class="language-fsharp">type RenderedContentItem = {
    SourcePath: string
    OutputPath: string      // e.g., &quot;developer-quest/index.html&quot;
    HtmlContent: string     // Final HTML with resolved wiki links
    ExcerptHtml: string option
    Meta: FrontMatter
    PageMeta: PageMeta
    Kind: string
}
</code></pre>
<h3 id="key-functions">Key Functions</h3>
<h4 id="buildresolutioncontext">buildResolutionContext</h4>
<p>Creates lookup tables from all raw content:</p>
<ul>
<li>Normalizes titles (lowercase, trim, standardize spaces)</li>
<li>Maps titles to their corresponding content items</li>
<li>Maps titles to their output URLs</li>
</ul>
<h4 id="rendercontentitem">renderContentItem</h4>
<p>Renders a single content item with wiki link resolution:</p>
<ul>
<li>Creates context-aware Markdig pipeline</li>
<li>Passes ResolutionContext to WikiLinkExtension</li>
<li>Generates HTML with resolved links</li>
</ul>
<h3 id="wiki-link-resolution">Wiki Link Resolution</h3>
<p>The <code>WikiLinkExtension</code> has been enhanced to accept a <code>ResolutionContext</code>:</p>
<ol>
<li><strong>Parser</strong>: Identifies <code>[[wiki link]]</code> patterns in markdown</li>
<li><strong>Renderer</strong>: Uses ResolutionContext to resolve links:
<ul>
<li>Found in context → <code>&lt;a href=&quot;/path/&quot;&gt;Title&lt;/a&gt;</code></li>
<li>Not found → <code>&lt;span class=&quot;unresolved-link&quot;&gt;Title&lt;/span&gt;</code></li>
</ul>
</li>
</ol>
<h2 id="url-generation">URL Generation</h2>
<p>Content URLs are determined by:</p>
<ol>
<li><strong>Permalinks (first priority)</strong>: If frontmatter contains <code>permalink: some-slug</code></li>
<li><strong>Content type fallback</strong>:
<ul>
<li><strong>Posts</strong>: Uses permalink or filename as slug</li>
<li><strong>Pages</strong>: Uses filename (e.g., <code>about.html</code>)</li>
<li><strong>Notes</strong>: Uses slugified title (e.g., <code>/notes/machine-learning/</code>)</li>
</ul>
</li>
</ol>
<h3 id="important-posts-use-permalinks-not-date-based-urls">Important: Posts use permalinks, not date-based URLs</h3>
<p>The system prioritizes permalinks from frontmatter over date-based paths extracted from filenames.</p>
<h2 id="memory-characteristics">Memory Characteristics</h2>
<p>Option 3 holds all content in memory during processing:</p>
<ul>
<li><strong>Small sites (100 items)</strong>: ~3-6MB peak memory</li>
<li><strong>Medium sites (1,000 items)</strong>: ~30-60MB peak memory</li>
<li><strong>Large sites (10,000 items)</strong>: ~300-600MB peak memory</li>
</ul>
<p>For most blogs, this is negligible on modern hardware.</p>
<h2 id="benefits-of-option-3">Benefits of Option 3</h2>
<ol>
<li><strong>Improved Wiki Link Resolution</strong>: Links between content now resolve correctly</li>
<li><strong>Single-Pass Generation</strong>: More efficient than re-processing HTML</li>
<li><strong>Clean Architecture</strong>: Clear separation between loading, resolution, and rendering</li>
<li><strong>Extensible</strong>: Easy to add more cross-content features (backlinks, related content, etc.)</li>
</ol>
<h2 id="program-flow-program.fs">Program Flow (Program.fs)</h2>
<p>The main program flow has been updated to use Option 3:</p>
<pre><code class="language-fsharp">// Phase 1: Load raw content (no HTML generation)
let rawPosts = Renderer.loadRawPosts postsDir
let rawPages = Renderer.loadRawPages sourceDir
let rawNotes = Renderer.loadRawNotes notesDir

// Phase 2: Build resolution context
let allRawContent = rawPosts @ rawPages @ rawNotes
let resolutionContext = Renderer.buildResolutionContext allRawContent

// Phase 3: Render with context
let posts = rawPosts |&gt; List.map (fun raw -&gt; 
    Renderer.renderContentItem raw resolutionContext 
    |&gt; Renderer.renderedContentItemToContentItem)
// ... similar for pages and notes

// Phase 4: Continue with standard site generation
let index = Renderer.buildSiteIndex posts pages notes
// ...
</code></pre>
<h2 id="testing-strategy">Testing Strategy</h2>
<p>The implementation follows Test-Driven Development (TDD):</p>
<ol>
<li><strong>Integration Tests</strong>: Test complete wiki link resolution pipeline</li>
<li><strong>Unit Tests</strong>: Test individual components (models, resolution, rendering)</li>
<li><strong>Validation Script</strong>: <code>scripts/validate-site.fsx</code> ensures generated site integrity</li>
</ol>
<h2 id="migration-notes">Migration Notes</h2>
<p>Option 3 is fully backward compatible:</p>
<ul>
<li>Existing templates work unchanged</li>
<li>Output structure remains the same</li>
<li>Only the internal processing pipeline has changed</li>
</ul>
<h2 id="future-enhancements">Future Enhancements</h2>
<p>The deferred rendering architecture enables:</p>
<ul>
<li>Bidirectional links (backlinks)</li>
<li>Tag-based content networks</li>
<li>Dependency graphs</li>
<li>Advanced content relationships</li>
<li>Link validation and reporting</li>
</ul>
</article></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>