<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>Honest Return Types</title><meta name="description" content="Part 2 of Designing clear method signatures"><meta name="author" content="Devon Burriss"><meta itemprop="name" content="Honest Return Types"><meta itemprop="description" content="Part 2 of Designing clear method signatures"><meta itemprop="image" content="https://devonburriss.me/img/explore-590.jpg"><link rel="canonical" href="https://devonburriss.me/honest-return-types/"><meta itemprop="datePublished" content="2017-03-14" id="date"><meta itemprop="dateModified" content="2017-03-14" id="mdate"><meta itemprop="headline" content="Honest Return Types - Part 2 of Designing clear method signatures"><meta itemprop="mainEntityOfPage" content="https://devonburriss.me/honest-return-types/"><meta name="headline" content="Honest Return Types - Part 2 of Designing clear method signatures"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="Honest Return Types"><meta name="twitter:description" content="Part 2 of Designing clear method signatures"><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/explore-590.jpg"><meta property="og:title" content="Honest Return Types"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/honest-return-types/"><meta property="og:image" content="https://devonburriss.me/img/explore-590.jpg"><meta property="og:description" content="Part 2 of Designing clear method signatures"><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script></head><body><header class="site-header"><nav class="site-nav"><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><span style="display:contents"><header class="page-header"><h1>Honest Return Types</h1><p class="page-subtitle">Part 2 of Designing clear method signatures</p><p class="post-meta">Devon Burriss &#183; Mar 14, 2017</p></header><div class="topic-pills"><a class="topic-pill" href="/topics/engineering-practices/" title="How we build, test, and validate software.">Engineering Practices</a><a class="topic-pill" href="/topics/platforms-runtime/" title="Runtimes and execution environments (not frameworks).">Platforms &amp; Runtime</a></div><hr></span><article class="prose"><p>In <a href="/honest-arguments">Part 1</a> we looked at ways of making your code more descriptive by using custom types instead of simple types like <code>string</code>. In this article we will look at what your return type can tell you about a method.</p>
<blockquote>
<p>Updated: 19 March 2017</p>
</blockquote>
<!--more-->
<h1 id="honest-return-types">Honest Return Types</h1>
<p>For most of this post let us build on the example of a <code>Person</code> repository. We are not going to dive into implementation but instead focus on the descriptiveness of the return type. Our starting point is this:</p>
<pre><code class="language-csharp">public interface IQueryPerson
{
    Person Get(Email email);
}
</code></pre>
<p>The return type should be honest about what can happen when you call a method. Does this repository method return <code>null</code> if no record is found? Does it throw and exception? Does it return a <a href="https://martinfowler.com/eaaCatalog/specialCase.html">special case</a> subtype? Wouldn't it be nice if your return type could tell you this instead of you having to dig into the implementation to find out.</p>
<p>My 2 criteria are:</p>
<ol>
<li>A return type should be really descriptive of what the possible outcomes are</li>
<li>The interface for interacting with a type should make it difficult for developers to do the wrong thing</li>
</ol>
<h2 id="result-a-first-try">Result: A first try</h2>
<p>One solution is a <code>Result&lt;T&gt;</code> or some such flavour. It might look something like this:</p>
<pre><code class="language-csharp">public class Result&lt;T&gt;
{
    public T Value { get; set; }
    public bool IsSuccess { get; set; }
    public IEnumerable&lt;string&gt; Errors { get; set; }
    public Result()
    {
        Errors = new List&lt;string&gt;();
    }

    public Result(T value)
    {
        if(value == null)
        {
            IsSuccess = false;
        }
        else
        {
            IsSuccess = true;
            Value = value;
        }
    }
}
</code></pre>
<p>This could be written in slightly different ways, with error codes instead of string for Errors, or even <code>Exception</code>. Let's discuss the pros and cons of this.</p>
<h3 id="pros">Pros</h3>
<ul>
<li>It does acknowledge that something could go wrong</li>
<li>Can return some error and state information without throwing an exception (read unexplicit <code>goto</code> statement)</li>
</ul>
<h3 id="cons">Cons</h3>
<ul>
<li>It is not descriptive about what represents a failure</li>
<li>Value can be accessed without checking for success</li>
<li>The type doesn't convey whether <code>null</code> could still be a valid value</li>
</ul>
<p>So it is something but doesn't really fulfill either of my criteria very well. We are going to have to take a quick sidebar and talk about representing <code>null</code>. <code>Result&lt;T&gt;</code> doesn't tell us whether we should expect <code>T</code> to be <code>null</code> and whether that is valid.</p>
<h2 id="functional-side-bar">Functional side-bar</h2>
<p>In functional terms an elevated type is like a wrapper. It is a higher level of abstraction that allows us to work with the type in a predictable way. <code>IEnummerable&lt;T&gt;</code>, <code>Option&lt;T&gt;</code>, <code>Exception&lt;T&gt;</code>, <code>Either&lt;L. R&gt;</code>, <code>Validation&lt;T&gt;</code> are all examples of elevated types.</p>
<h2 id="option-null-is-none">Option: <code>null</code> is None</h2>
<p>&quot;It depends&quot; is something you hear a lot in development, and wouldn't it be great if a type conveyed this? <code>Option</code> or <code>Maybe</code> are types often found in more functional languages that highlight the fact that a value could not be present. It allows you to say that there is <code>Some</code> value, or the value is <code>None</code>. This is probably easier to demonstrate...</p>
<blockquote>
<p>I am using <a href="https://github.com/louthy/language-ext">LanguageExt</a> to get some more functional types. This one is mature and fully featured but pick whatever works for you.</p>
</blockquote>
<pre><code class="language-csharp">public Option&lt;Person&gt; Get(Email email)
{
    Person person = QueryByEmail(email);//person could be null if no matching email found in the datasource
    return person;
}

//usage example
var person1 = personRepository.Get(email);

//print out last name if person was found otherwise print &quot;Nobody&quot;
person1.Match(
    Some: p =&gt; Console.WriteLine(p.LastName),
    None: () =&gt; Console.WriteLine(&quot;Nobody&quot;)
);

//return fullname or Nobody if no one was found
var person1Name = person1.Match(
    Some: p =&gt; $&quot;{p.FirstNames} {p.LastName}&quot;,
    None: () =&gt; &quot;Nobody&quot;
);
</code></pre>
<p>The implementation uses <code>implicit</code> conversion to return <code>None</code> if the value is <code>null</code> otherwise the <code>Person</code> is elevated with Some.<br />
I explicitly elevate the result to demonstrate what is happening. Let's also add some error-handling as this will show a problem.</p>
<pre><code class="language-csharp">using static LanguageExt.Prelude;
public Option&lt;Person&gt; Get(Email email)
{
    try
    {
        Person person = QueryByEmail(email);
        if(person == null)
            return None;
        return Some(person);
    }
    catch (Exception)
    {
        return None;
    }
}
</code></pre>
<p>So this is looking a little better.</p>
<h3 id="pros-1">Pros</h3>
<ul>
<li>Return type is explicit about possibility of no value being returned</li>
<li>The API of the type encourages handling of branch between happy and unhappy path</li>
</ul>
<h3 id="cons-1">Cons</h3>
<ul>
<li>We cannot differentiate between no value and an exception</li>
</ul>
<h2 id="exception-return-dont-throw">Exception: return don't throw</h2>
<blockquote>
<p>The following <code>Exceptional&lt;T&gt;</code> and <code>Validation&lt;T&gt;</code> types are defined in <a href="https://github.com/dburriss/HonestTypes">HonestTypes</a>. Check the project page for installation instructions.</p>
</blockquote>
<p>So our type needs to be a bit more explicit about what can happen. Let's introduce an <code>Exceptional&lt;T&gt;</code> type.
This is similar to <code>Option&lt;Person&gt;</code> but instead of <strong>Some</strong> and <strong>None</strong> it has <strong>Exception</strong> and <strong>Success</strong>.<br />
For those of you familiar with functional programming it is basically <code>Either&lt;Exception, T&gt;</code> with left set to <code>Exception</code>.</p>
<pre><code class="language-csharp">public Exceptional&lt;Option&lt;Person&gt;&gt; Get(Email email)
{
    try
    {
        Person person = QueryByEmail(email);
        Option&lt;Person&gt; result = person;
        return result;
    }
    catch (DbException ex)//only catch expected exceptions
    {
        return ex;
    }
}

//usage
var person1 = personRepository.Get(email);

person1.Match(
    Exception: ex =&gt; Console.WriteLine($&quot;Exception: {ex.Message}&quot;),
    Success: opt =&gt; opt.Match(
        None: () =&gt; Console.WriteLine(&quot;Person: Nobody&quot;),
        Some: p =&gt; Console.WriteLine($&quot;Person: {p.FirstNames} {p.LastName}&quot;)
    )
);
</code></pre>
<p>One important point in the repository implementation is you need to assign it to <code>Option&lt;Person&gt;</code> before returning it which implicitly converts to <code>Exceptional&lt;Option&lt;Person&gt;&gt;</code>.
You can't go directly from <code>Person</code> to <code>Exceptional&lt;Option&lt;Person&gt;&gt;</code> unfortunately.</p>
<p>The difference in this implementation is in the exception handling. See how we just return the exception? The exception has an implicit conversion to the elevated type of <code>Exceptional&lt;T&gt;</code>.</p>
<h3 id="pros-2">Pros</h3>
<ul>
<li>Return type is very explicit about both errors and no value</li>
<li>API of return type encourages good handling of code paths</li>
</ul>
<h3 id="cons-2">Cons</h3>
<ul>
<li>With the nested generics the type declaration is quite verbose</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>So with a bit of borrowing from functional programming and some added verbosity to our method signature we managed to move from an admittedly simple signature to a slightly more verbose one that is brutally honest about the possible outcomes.</p>
<pre><code class="language-csharp">Person Get(Email email);
Result&lt;Person&gt; Get(Email email);
Option&lt;Person&gt; Get(Email email);
Exceptional&lt;Option&lt;Person&gt;&gt; Get(Email email);
</code></pre>
<p>I hope you found something useful in this and if you did I cannot recommend enough the brilliant <a href="https://www.manning.com/books/functional-programming-in-c-sharp">Functional Programming in C#</a> from Manning. I must warn that some of the chapters in this book are heavy going. Not because they are badly written but because as a C# and Java developer the concepts are so foreign that they take a while to sink in. Like most things worthwhile it takes effort and determination but you will be a better developer for it.</p>
<p>In my following post I will discuss <a href="/better-error-handling">error handling</a> and how logic/validation errors can be represented as return types following the same criteria as in this post.</p>
<h2 id="recommended-reading">Recommended Reading</h2>
<ol>
<li><a href="https://fsharpforfunandprofit.com/posts/elevated-world/">Elevated world</a></li>
<li><a href="https://fsharpforfunandprofit.com/rop/">Railway oriented programming</a></li>
</ol>
</article><hr><nav class="pager"><ul class="pager-links"><li><a href="/honest-arguments/" title="Honest Arguments">← Previous</a></li><li><a href="/better-error-handling/" title="Better error handling">Next →</a></li></ul></nav></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><div class="comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'devonburriss';(function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'https://devonburriss.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>