<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>Useful FP language features</title><meta name="description" content="A review of some language features like immutability and algebraic data types that work well in a functional style of programming."><meta name="author" content="Devon Burriss"><meta itemprop="name" content="Useful FP language features"><meta itemprop="description" content="A review of some language features like immutability and algebraic data types that work well in a functional style of programming."><meta itemprop="image" content="https://devonburriss.me/img/posts/2018/hammer-500.jpg"><link rel="canonical" href="https://devonburriss.me/useful-fp-language-features/"><meta itemprop="datePublished" content="2021-12-23" id="date"><meta itemprop="dateModified" content="2021-12-23" id="mdate"><meta itemprop="headline" content="Useful FP language features - Making functional programming more productive"><meta itemprop="mainEntityOfPage" content="https://devonburriss.me/useful-fp-language-features/"><meta name="headline" content="Useful FP language features - Making functional programming more productive"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="Useful FP language features"><meta name="twitter:description" content="A review of some language features like immutability and algebraic data types that work well in a functional style of programming."><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/posts/2018/hammer-500.jpg"><meta property="og:title" content="Useful FP language features"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/useful-fp-language-features/"><meta property="og:image" content="https://devonburriss.me/img/posts/2018/hammer-500.jpg"><meta property="og:description" content="A review of some language features like immutability and algebraic data types that work well in a functional style of programming."><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script></head><body><header class="site-header"><nav class="site-nav"><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><span style="display:contents"><header class="page-header"><h1>Useful FP language features</h1><p class="page-subtitle">Making functional programming more productive</p><p class="post-meta">Devon Burriss &#183; Dec 23, 2021</p></header><div class="topic-pills"><a class="topic-pill" href="/topics/platforms-runtime/" title="Runtimes and execution environments (not frameworks).">Platforms &amp; Runtime</a></div><hr></span><article class="prose"><p>In a <a href="/what-is-fp">previous post</a> we looked at the big ideas of functional programming. In this post we will look at some features that are often associated with functional programming but that I do not think are core to it.</p>
<!--more-->
<p>Some of these are conflated with functional programming but it turns out that the only language feature needed for functional programming is support for higher-order functions.</p>
<h2 id="immutable-data">Immutable data</h2>
<p>To work with pure functions, you need to be careful not to change the underlying state of you application. This includes the input to your functions. It is useful if your language can enforce this.</p>
<p>I was presenting to a group of Javascript and C# developers a few weeks ago and I showed the following C# snippet of code.</p>
<pre><code class="language-csharp">// what does this return?
var two = 1 + 1;
return two++;
</code></pre>
<p>Now maybe this is a bit unfair but I think it highlights the problem of reasoning about mutable state as statements are executed. When I polled the audience on this it seemed about a 50/50 split between answers of 2 and answers of 3. If anything, more answers of 3. If you are not sure, it turns out the number 2 is returned. Any subsequent references to <code>two</code> would reference the value 3.</p>
<p>Now granted, the <code>++</code> operator is not the most intuitive and you need to know the behaviour expected depending on what side of the variable it is place. It is useful in illustrating how state can change in ways we might not anticipate.</p>
<p>In the F# example below, you see that a value is immutable. Once it's value is set, it cannot be changed.</p>
<pre><code class="language-fsharp">let two = 1 + 1
//let two = 3 // will not compile
//let two &lt;- 3 // will not compile
</code></pre>
<p>Once you have immutable values, it is important to have an easy way to create new values from old ones. An often overlooked area here is having good tools for working with immutable collections.</p>
<pre><code class="language-fsharp">let stock = [ (&quot;chicken&quot;, 20);(&quot;grain&quot;, 50);(&quot;potatoes&quot;, 30) ] |&gt; Map.ofList
// create a new map from an existing one
let newStock = stock |&gt; Map.change &quot;chicken&quot; (fun vOpt -&gt; vOpt |&gt; Option.map (fun v -&gt; v - 1))
</code></pre>
<p>Above we see that rather than changing the value in the map, a new map is returned with the changed value.</p>
<h3 id="benefits">Benefits</h3>
<ul>
<li>Easier to reason about</li>
<li>Fewer bugs due to unexpected state changes</li>
<li>Easier parallel processing</li>
</ul>
<h2 id="algebraic-data-types">Algebraic data types</h2>
<p>Algebraic data types are comprised of <strong>product</strong> types and <strong>sum</strong> types.</p>
<p>Sidebar: I am not the person to be trying to explain Type Theory. I am not even sure if there exists a formal definition of class and how it relates to a type (in a language agnostic way). If you are an OO programmer think of a type as a concrete class. So <code>Nullable&lt;T&gt;</code> is a class, <code>Nullable&lt;int&gt;</code> is a type and <code>Nullable&lt;decimal&gt;</code> is another type. My current thinking of a class is as a parameterized factory for a type, if it is generic. If not they can be considered equivalent. Experts, let me know in the comments all the ways this is wrong :)</p>
<p><strong>Product types</strong> are either records or tuples which in OO languages are common data structure types.</p>
<pre><code class="language-fsharp">type IntAndBool = {
    I : uint
    B : bool
}

let p = { I = 0u ; B = true }

// range of possible values
printfn &quot;product %i&quot; (((UInt32.MaxValue |&gt; int64) + 1L) * (2L)) // range of uint * range of bool
// product 8589934592
</code></pre>
<p>Giving as a total possible range of 8589934592 combinations, found by multiplying the possible number of states in each field.</p>
<p>So I bet you can guess where <strong>sum types</strong> get there name from now...</p>
<p><strong>Sum types</strong> are known by many names and appear primarily in functional-first languages (tagged union, discriminated union, choice type, to name a few). The only OO leaning language I personally know that has something like <strong>sum types</strong> is TypeScript's Union types.</p>
<p>These types allow us to define types that can be something, or something else. An example will illustrate this best.</p>
<pre><code class="language-fsharp">type IntOrBool = I of uint | B of bool

let s = B true

(((UInt32.MaxValue |&gt; int64) + 1L) + 2L)
printfn &quot;sum %i&quot; (((UInt32.MaxValue |&gt; int64) + 1L) + (2L)) // range of uint + range of bool
// sum 4294967298
</code></pre>
<p>An instance of <code>IntOrBool</code> can be either one type or the other. There is no need to constrain these to combining simple types though. We can model using more complex types.</p>
<pre><code class="language-fsharp">type PostalCode = string
type Address = { 
    HouseNumber : int
    HouseNumberOpt : char option
    StreetName : string
    City : string
    PostalCode : PostalCode
}
type EmailAddress = string
type PhoneNumber = string
type ContactMethod = Email of EmailAddress | Post of Address | Phone of PhoneNumber
</code></pre>
<p>Here you see the <code>ContactMethod</code> type can be <code>EmailAddress</code> OR <code>Address</code> OR <code>PhoneNumber</code>. This gives a far more rich and intuitive way of modelling a domain.</p>
<p>A language that supports <strong>sum types</strong> typically provides elegant ways of dealing with 2 prickly issues in programming.<br />
Too often the absence of something is represented by <code>null</code>. &quot; The billion dollar mistake yada yada...&quot;.
In functional languages the approach is to use a sum type, usually called <code>Option</code> or <code>Maybe</code>.</p>
<pre><code class="language-fsharp">let noValue = None
let someValueThatCouldBeNone = Some 42
printfn &quot;is equal? %b&quot; (noValue = someValueThatCouldBeNone)
// is equal? false
</code></pre>
<p>A similar approach can be taken to exceptions. Instead of throwing an exception that is hopefully handled somewhere, we return from the function that it was possible for an exception to have occurred.</p>
<pre><code class="language-fsharp">let success = Ok 42
let error = Error &quot;Something went wrong calculating the meaning of life&quot;
printfn &quot;is equal? %b&quot; (noValue = someValueThatCouldBeNone)
// is equal? false
</code></pre>
<blockquote>
<p>Note: This could be the point where some might be wondering where I am going to start throwing the word Monad. This article will not. Monad, monoid, etc. are patterns as far as I am concerned. Their origins may be far more formal than the observational origins of OOP patterns like Vistor, or Strategy, but they are patterns none the less (in my opinion). The are no more necessary for FP than patterns are for OOP. Using them well can improve your code. Using them poorly can make it overly complicated.</p>
</blockquote>
<h3 id="benefits-1">Benefits</h3>
<ul>
<li>They should be immutable</li>
<li>They should have value equality</li>
<li>More powerful modelling options without resorting to inheritance</li>
</ul>
<h2 id="pattern-matching">Pattern matching</h2>
<p>The final language feature I will point out is pattern matching. This is making it's way into C# now but for me the combination of pattern matching with <strong>sum types</strong> is what I miss most when working in a language that does not support algebraic types.</p>
<pre><code class="language-fsharp">let calculateMeaning() =
    if ((Random()).Next() % 2) = 0 then Ok 42
    else Error &quot;Something went wrong calculating the meaning of life&quot;

match calculateMeaning() with
| Ok nr -&gt; printfn &quot;The answer to life is %i&quot; nr
| Error err -&gt; printfn &quot;%s&quot; err
</code></pre>
<p>When calculating the meaning of life, the returning result will be of type <code>Result&lt;int,string&gt;</code>. We can <code>match</code> on this where we handle each case that is possible. If you have a statically typed language the compiler can tell you when your match is not covering every case.</p>
<p>If working with <code>Option</code> or <code>Result</code> sounds interesting to you, I suggest checking out <a href="https://fsharpforfunandprofit.com/rop/">Railway oriented programming</a>.</p>
<h3 id="benefits-2">Benefits</h3>
<ul>
<li>Often results in easier to understand control flow</li>
<li>In some languages, the compiler can tell you if all possibilities are matched against</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>In this post we covered a few language features that are nice to have for making you development experience using functional programming productive. These support the ideas of FP and make it faster to write code that is bug free. This post was mostly about addressing things that where not in the <a href="/what-is-fp">previous post</a>. Finally, monads, etc. were not covered at all, since I consider them patterns. Although they are intimately connected with FP, I do not think they are strictly necessary to say you are writing code using the principles of FP.</p>
</article><hr><nav class="pager"><ul class="pager-links"><li><a href="/what-is-fp/" title="What is Functional Programming?">← Previous</a></li><li><a href="/fp-architecture/" title="A simple FP architecture">Next →</a></li></ul></nav></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><div class="comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'devonburriss';(function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'https://devonburriss.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>