<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>Reliable APIs - Part 2</title><meta name="description" content="An example of a bad resilience implementation and discussion of the failure modes."><meta name="author" content="Devon Burriss"><meta itemprop="name" content="Reliable APIs - Part 2"><meta itemprop="description" content="An example of a bad resilience implementation and discussion of the failure modes."><meta itemprop="image" content="https://devonburriss.me/img/posts/2019/target-500.jpg"><link rel="canonical" href="https://devonburriss.me/reliable-apis-part-2/"><meta itemprop="datePublished" content="2021-08-23" id="date"><meta itemprop="dateModified" content="2021-08-23" id="mdate"><meta itemprop="headline" content="Reliable APIs - Part 2 - Using Idempotency-Key and a response cache"><meta itemprop="mainEntityOfPage" content="https://devonburriss.me/reliable-apis-part-2/"><meta name="headline" content="Reliable APIs - Part 2 - Using Idempotency-Key and a response cache"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="Reliable APIs - Part 2"><meta name="twitter:description" content="An example of a bad resilience implementation and discussion of the failure modes."><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/posts/2019/target-500.jpg"><meta property="og:title" content="Reliable APIs - Part 2"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/reliable-apis-part-2/"><meta property="og:image" content="https://devonburriss.me/img/posts/2019/target-500.jpg"><meta property="og:description" content="An example of a bad resilience implementation and discussion of the failure modes."><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script></head><body><header class="site-header"><nav class="site-nav"><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><span style="display:contents"><header class="page-header"><h1>Reliable APIs - Part 2</h1><p class="page-subtitle">Using Idempotency-Key and a response cache</p><p class="post-meta">Devon Burriss &#183; Aug 23, 2021</p></header><div class="topic-pills"><a class="topic-pill" href="/topics/reliability-observability/" title="Monitoring, metrics, reliability, and failure modes.">Reliability &amp; Observability</a><a class="topic-pill" href="/topics/software-design/" title="Architecture, design, modeling, and distributed systems.">Software Design</a></div><hr></span><article class="prose"><p>In the <a href="/reliable-apis-part-1">previous post</a> we saw how you can end up with duplicates if using a retry-policy on a call to a non-idempotent endpoint. In this post, we will look at correcting this and see a subtle way that this can go wrong.</p>
<!--more-->
<p>Posts in this series:</p>
<ol>
<li><a href="/reliable-apis-part-1">Exploring reties, retry implications, and the failure modes they are appropriate for</a></li>
<li>Using Idempotency-Key and a response cache</li>
<li><a href="/reliable-apis-part-3">The epic saga of client-side IDs and true idempotence</a></li>
</ol>
<p>When we last saw our young developer, they had learned a lesson about the indiscriminate use of retry policy. This led to some insightful telemetry to be able to monitor when the system landed in an inconsistent state.</p>
<p>A good thing too! The e-commerce company our developer works at is expanding into another country and to cope with the increase in buying across 2 countries, they are automating the restocking. A sister team has been working with the data science team to develop an intelligent resupply service that will be making use of the supplier ordering API to automatically create orders. Currently, inconsistencies only happen once every week or two but with an increase in load, this will start getting even more annoying for both the development team and purchasers. Our young developer has raised that they want to have this fixed and stable before the automation kicks in.</p>
<p>As a reminder, this is the current design:</p>
<p><img src="../img/posts/2021/2021-08-22-10-38-55.png" alt="Current design" /></p>
<p>Let's see how our young developer is getting along...</p>
<h2 id="that-idempotence-thing">That idempotence thing</h2>
<p>So you stopped using XML and SOAP and started sending JSON so you figured you had this REST stuff down. If the last few weeks has taught you anything though it is that there is way more to this API design than the getting started pages on web frameworks tell you. You do recall this idea of <em>idempotent</em> calls though and this seems like what you are looking for. Searching for solutions, the internet seems to be a dumpster fire of people arguing about whether POST should be idempotent or not. Going to the source and reading the POST section of the <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.3">RFC</a> you decide on:</p>
<ul>
<li>Respond with <code>201 Created</code> if the resource does not exist</li>
<li>Respond with <code>303 See Other</code> if the resource already exists</li>
</ul>
<p>So apparently a POST can be idempotent. Regardless of the spec, this just seems like a good idea.</p>
<p>The more difficult question is, how to tell if a request is a duplicate? Apparently, the semantic way to handle this would be to use <a href="https://tools.ietf.org/id/draft-idempotency-header-01.html">Idempotency-Key</a>.<br />
The <code>Idemptency-Key</code> is a header you place in a request that indicates a unique request. So for each create order request you send to your API, it will have a unique UUID. Now you can retry a request if it fails, you can retry the request with the same <code>Idemptency-Key</code> as the failed request.</p>
<p>For the API our young developer comes up with the following design. The whole team is really excited about adding Redis to their stack as a cache. Not only will it be used as the <code>Idemptency-Key</code> cache but as a response cache in general.</p>
<p><img src="../img/posts/2021/2021-08-23-06-19-59.png" alt="With cache" /></p>
<p>Before servicing a request, the create order endpoint will check to see if the <code>Idemptency-Key</code> is already in the cache and if it is, it will just return the cached response. If it is not in the cache, it will proceed with the rest of the call and at the end, place the response in the cache.</p>
<p>Now that the endpoint is idempotent, you go ahead and re-enable that retry policy from the client-side.</p>
<h2 id="not-again">Not again!</h2>
<p>The day after deploying your new resiliency changes you get a call from one of the new stock purchasers, Leon. Leon is an older guy who wanted a change from warehousing, an area he had been working for decades. He mentions that he has noticed some inconsistencies but wants to check them with you since he does not know these new systems. You smile to yourself because Leon does not seem very comfortable on the computer. He double clicks everything and types with one finger. Leon brings up the application that shows the purchase orders created on our side. He also brings up the portal they use that shows them incoming deliveries from the supplier. It takes a while but eventually he puts these 2 screens next to each other. There are orders that have been created on our side and do not exist at the supplier. Not only that but duplicates are back!<br />
Leon points out something else interesting. He noticed that his orders seem to be duplicated far more often than the other purchasers. He is worried he is doing something wrong since he knows he isn't great at this computer stuff.<br />
You are pretty sure you know what is wrong and you can't believe you made this mistake again. You explain to Leon that he does not need to double click the button but assure him that the fault is not his but rather yours. Leon not only found a bug earlier than everyone else but because he had checked at the supplier, he was able to fix the orders before deliveries were sent. Thank you, Leon!</p>
<h2 id="quick-fix">Quick fix</h2>
<p>You are pretty sure you know what is going on. Leon's double-clicking meant that sometimes a second request was making it into the endpoint before the first call had been completed and was cached. Now that you are thinking through it, the current design hardly adds any value at all from a resilience point of view. You are shocked. Annoyed with yourself because the reason you had not looked at this more critically before was that this was the advice of countless posts and libraries on the internet. Maybe people just don't make POST requests idempotent? Or the people giving the advice don't work on distributed systems? Maybe they just don't have telemetry telling them how often this goes wrong? Looking at yours, it indeed confirms Leon's findings. Apparently, you need to invest in even better metrics and alerts.</p>
<p>You implement some quick fixes. Firstly, you disable the retry policy. Again. Next, you add a quick change to the UI that disables the button until a response is received. That should take care of Leon's double-clicking.</p>
<p>Back to the drawing board.</p>
<h2 id="analysis">Analysis</h2>
<p>So what went wrong with our friend's design this time? Basically, concurrency makes everything just a little bit more complex. When walking through a sequence of steps in our program it can be difficult to think about what this means for other executions happening at the same time. The kind of bugs that can arise from this can be rather subtle and confusing.</p>
<p>Here is just one example of 2 requests hitting the endpoint before the cache has been updated.</p>
<p><a href="https://mermaid-js.github.io/mermaid-live-editor/edit/##eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQ2xpZW50LT4-K0FQSTogQ3JlYXRlIG9yZGVyIHJlcXVlc3QgW29yaWddXG4gICAgQVBJLT4-K0NhY2hlIDogQ2hlY2sgZm9yIElkZW1wb3RlbmN5LUtleSBbb3JpZ11cbiAgICBDYWNoZS0-Pi1BUEkgOiBObyBrZXkgZm91bmQgW29yaWddXG4gICAgQ2xpZW50LT4-QVBJOiBEdXBsaWNhdGUgY3JlYXRlIG9yZGVyIHJlcXVlc3QgW2R1cF1cbiAgICBBUEktPj4rQ2FjaGUgOiBDaGVjayBmb3IgSWRlbXBvdGVuY3ktS2V5IFtkdXBdXG4gICAgQ2FjaGUtPj4tQVBJIDogTm8ga2V5IGZvdW5kIFtkdXBdXG4gICAgQVBJLT4-REIgOiBQZXJzaXN0IHJlY29yZCBbb3JpZ11cbiAgICBBUEktPj5TdXBwbGllciBBUEkgOiBTZW5kIG9yZGVyIFtvcmlnXVxuICAgIEFQSS0-PkRCIDogUGVyc2lzdCByZWNvcmQgW2R1cF1cbiAgICBBUEktPj5TdXBwbGllciBBUEkgOiBTZW5kIG9yZGVyIFtkdXBdXG4gICAgQVBJLT4-Q2FjaGUgOiBVcGRhdGUgY2FjaGUgW29yaWddXG4gICAgQVBJLT4-Q2FjaGUgIDogVXBkYXRlIGNhY2hlIFtkdXBdXG4gICAgQVBJLS0-PkNsaWVudDogT3JkZXIgY3JlYXRlZCByZXNwb25zZSBbb3JpZ11cbiAgICBBUEktLT4-LUNsaWVudDogT3JkZXIgY3JlYXRlZCByZXNwb25zZSBbZHVwXVxuICAgICIsIm1lcm1haWQiOiJ7XG4gIFwidGhlbWVcIjogXCJkZWZhdWx0XCJcbn0iLCJ1cGRhdGVFZGl0b3IiOmZhbHNlLCJhdXRvU3luYyI6dHJ1ZSwidXBkYXRlRGlhZ3JhbSI6ZmFsc2V9"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgQ2xpZW50LT4-K0FQSTogQ3JlYXRlIG9yZGVyIHJlcXVlc3QgW29yaWddXG4gICAgQVBJLT4-K0NhY2hlIDogQ2hlY2sgZm9yIElkZW1wb3RlbmN5LUtleSBbb3JpZ11cbiAgICBDYWNoZS0-Pi1BUEkgOiBObyBrZXkgZm91bmQgW29yaWddXG4gICAgQ2xpZW50LT4-QVBJOiBEdXBsaWNhdGUgY3JlYXRlIG9yZGVyIHJlcXVlc3QgW2R1cF1cbiAgICBBUEktPj4rQ2FjaGUgOiBDaGVjayBmb3IgSWRlbXBvdGVuY3ktS2V5IFtkdXBdXG4gICAgQ2FjaGUtPj4tQVBJIDogTm8ga2V5IGZvdW5kIFtkdXBdXG4gICAgQVBJLT4-REIgOiBQZXJzaXN0IHJlY29yZCBbb3JpZ11cbiAgICBBUEktPj5TdXBwbGllciBBUEkgOiBTZW5kIG9yZGVyIFtvcmlnXVxuICAgIEFQSS0-PkRCIDogUGVyc2lzdCByZWNvcmQgW2R1cF1cbiAgICBBUEktPj5TdXBwbGllciBBUEkgOiBTZW5kIG9yZGVyIFtkdXBdXG4gICAgQVBJLT4-Q2FjaGUgOiBVcGRhdGUgY2FjaGUgW29yaWddXG4gICAgQVBJLT4-Q2FjaGUgOiBVcGRhdGUgY2FjaGUgW2R1cF1cbiAgICBBUEktLT4-Q2xpZW50OiBPcmRlciBjcmVhdGVkIHJlc3BvbnNlIFtvcmlnXVxuICAgIEFQSS0tPj4tQ2xpZW50OiBPcmRlciBjcmVhdGVkIHJlc3BvbnNlIFtkdXBdXG4gICAgIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZSwiYXV0b1N5bmMiOnRydWUsInVwZGF0ZURpYWdyYW0iOmZhbHNlfQ" alt="Concurrent requests to cache" /></a></p>
<p>As you can see in the sequence diagram, the first request comes in and then the second. The second check against the cache happens before the first request completes and updates the cache.</p>
<p>We also still have the problem that a call to the supplier API failing would leave our database in an inconsistent state. Depending on what went wrong we could retry, but what if the process was terminated at that point? A duplicate call could come in again.<br />
What if we updated the cache before the calls? Well then we could end up with either database or external API call failing and from the outside it seeming like it had succeeded.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This design of cache that is not transactional with state change within the service does not really move us closer to a resilient API design. In the next post, we will finally look at a design that does improve reliability.</p>
<h2 id="summary">Summary</h2>
<p><strong>Problem:</strong> Duplicate calls</p>
<p><strong>Solutions:</strong> idempotency via a response cache</p>
<p><strong>Consequence:</strong> Duplicate calls because cache update is not atomic</p>
<blockquote>
<p>Concurrency is hard</p>
</blockquote>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://stripe.com/blog/idempotency">Stripe blog on Idempotency</a></li>
<li><a href="https://repl.ca/what-is-the-idempotency-key-header/">Intro to Idempotency-Key header</a></li>
</ul>
</article><hr><nav class="pager"><ul class="pager-links"><li><a href="/reliable-apis-part-1/" title="Reliable APIs - Part 1">← Previous</a></li><li><a href="/reliable-apis-part-3/" title="Reliable APIs - Part 3">Next →</a></li></ul></nav></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><div class="comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'devonburriss';(function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'https://devonburriss.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>