<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>Anatomy of an automated test suite</title><meta name="description" content="Comparing structure and function of various test types to tease out what we really care to verify"><meta name="author" content="Devon Burriss"><meta itemprop="name" content="Anatomy of an automated test suite"><meta itemprop="description" content="Comparing structure and function of various test types to tease out what we really care to verify"><meta itemprop="image" content="https://devonburriss.me/img/posts/2018/pyramid-500.jpg"><link rel="canonical" href="https://devonburriss.me/anatomy-of-automated-testing/"><meta itemprop="datePublished" content="2018-08-13" id="date"><meta itemprop="dateModified" content="2018-08-13" id="mdate"><meta itemprop="headline" content="Anatomy of an automated test suite - Looking at the parts and functions of various automated test types"><meta itemprop="mainEntityOfPage" content="https://devonburriss.me/anatomy-of-automated-testing/"><meta name="headline" content="Anatomy of an automated test suite - Looking at the parts and functions of various automated test types"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="Anatomy of an automated test suite"><meta name="twitter:description" content="Comparing structure and function of various test types to tease out what we really care to verify"><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/posts/2018/pyramid-500.jpg"><meta property="og:title" content="Anatomy of an automated test suite"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/anatomy-of-automated-testing/"><meta property="og:image" content="https://devonburriss.me/img/posts/2018/pyramid-500.jpg"><meta property="og:description" content="Comparing structure and function of various test types to tease out what we really care to verify"><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script><script type="module" src="/js/search-ui.js"></script></head><body><header class="site-header"><nav class="site-nav"><a class="site-title nav-badge" href="/">DEVON BURRISS</a><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/notes/">Notes</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><span style="display:contents"><header class="page-header"><h1>Anatomy of an automated test suite</h1><p class="page-subtitle">Looking at the parts and functions of various automated test types</p><p class="post-meta">Devon Burriss &#183; Aug 13, 2018</p></header><div class="topic-pills"><a class="topic-pill" href="/topics/engineering-practices/" title="How we build, test, and validate software.">Engineering Practices</a></div><hr></span><article class="prose"><p>Unit, integration, end-to-end, acceptance, UI tests, and more. With so many types of automated tests is it no wonder that we so often disagree on whether something is an acceptance test or an integration test? Or maybe an end-to-end test? What if instead of thinking about the structure of the test, what it tested, we instead considered the question that the test is answering&hellip;</p>
<!--more-->
<h2 id="a-quick-note-on-the-test-pyramid">A quick note on the test pyramid</h2>
<p>For some reason, the test pyramid comes up when talking about what tests to write. The test pyramid gives us an indication of the relative return on investment of writing certain types of tests. The cost of writing and maintaining UI tests is usually quite high, thus diminishing their value as verification of correctness. Unit tests, on the other hand, should be pretty quick to write, easy to maintain, and so give more value over UI tests. Therefore we should have a relatively large number of unit tests compared to UI tests.</p>
<p>In this image, I use <em>Service</em> to encompass integration, end-to-end, acceptance tests, etc.</p>
<p><img src="/img/posts/2018/test-pyramid.jpg" alt="Test Pyramid" /></p>
<p>If we had a way that made <a href="/page-module-model/">UI tests easy to write and maintain</a>, they would switch places in the test pyramid. They might then provide more value relative to the cost of creation and maintenance.</p>
<h2 id="practices-around-testing">Practices around testing</h2>
<p>Let us take a look at some of the testing practices around and what they focus on. This will give us a good indication of what questions we can ask of our tests.</p>
<p>First up we have <strong>Test-Driven Development</strong>. A lot can be written about TDD and half of it would be disagreed with by half its practitioners half of the time. I will try to stay away from questions of what to mock and the granularity of the tests. I have <a href="/maintainable-unit-tests/">written about my thoughts on maintainable unit tests</a> already though. The practice of writing tests first, then making them pass, and then refactoring; gives fast and incremental feedback on both progress and the design of your code. While making functional progress a test suite is being built up that proves that what you have implemented is working as expected by you as the developer.</p>
<p><strong>Behavior-Driven Design</strong> builds on top of the idea of TDD but with a focus on capturing requirements in an automated way that fosters domain understanding and collaboration with stakeholders.</p>
<p>It really isn't clear to me that the 2 need to be separate practices. BDD is just TDD practiced by developers with a <a href="/acceptance-tests/">focus on domain knowledge and stakeholder collaboration</a>. On the other side, TDD has become what developers do when they are not focusing on stakeholder collaboration. This was not its original intent.</p>
<p>Honestly, though I do find the distinction a little bit useful in thinking about the kind of tests I am writing just because it allows me to ask questions about the quality of what was built and the functional correctness.</p>
<p><img src="/img/posts/2018/test-quadrant.jpg" alt="Test Quadrant" /></p>
<p>So for the sake of comparison, we will make the distinction that unit tests are an artifact of TDD and acceptance tests are an artifact of BDD. Don't get too attached to this idea, it is just useful for the upcoming discussion.</p>
<h2 id="asking-the-right-questions">Asking the right questions</h2>
<blockquote>
<p>UPDATE: I have noticed a lot of confusion when talking about Integration tests. In the context of this post I mean a narrow test that tests the connection handshake and contract with software outside of the process boundary. Typically I limit the scope of these but do not mock the external system, since that is the point of the test. If on the other hand there was a reliable way to verify the contract with fewer dependencies, I would be happy to drop this and name it a Contract Test.</p>
</blockquote>
<p>I promised some questions to be asked to give a different perspective on the types of tests. What if instead of thinking about tests in terms of how they were written (xUnit and C# vs Gherkin) we thought about them in terms of questions directed at the test?</p>
<p><em>Do I understand the problem?<br />
Is my feature ready to ship?<br />
Does it behave as expected?</em><br />
Check the <strong>Acceptance tests</strong>. Did it passed? Ship the feature.</p>
<p><em>Am I confident I built it well?<br />
Does my code handle exceptions correctly?<br />
Is my codes API intuitive to use?</em><br />
Check your <strong>Unit tests</strong>. Passes. I can am confident in the code. I can refactor with confidence.</p>
<p><em>Does my data access work against a real database?<br />
Do my API calls work as expected?<br />
Are my message queues configured correctly?</em><br />
Check the <strong>Integration tests</strong>. Passes. I am confident that I won't have surprises when the system runs. I will find integration problems quickly.</p>
<p>There are other types of tests like <strong>Consumer-driven contracts</strong> and <strong>UI tests</strong> that might be useful to you and I am sure you can come up with the questions if they matter to you. The point is that dividing your tests based on how they are implemented is less useful than distinguishing what answers each group of tests is good at giving.</p>
<h2 id="summary">Summary</h2>
<p>In this post, I suggested that instead of looking at tests based on what they test or how they are implemented, it is more useful to ask what questions they can answer. For example:<br />
<strong>Acceptance tests</strong> answer <em>Did I build the right thing?</em> and <em>Can I ship it?</em>.<br />
<strong>Unit tests</strong> give me confidence on <em>Did I build it right?</em>.<br />
<strong>Integration tests</strong> tell me <em>Can these components communicate?</em> I especially like checking across process boundaries here.</p>
<p>Hopefully, by this point, I have convinced you to think about your tests in terms of the questions they answer and the actions you will take from those questions.</p>
<p>One last thing. Much of the gain in TDD is that unit tests gives you rapid feedback. As long as you have good trustworthy acceptance tests, deleting unit tests if they are causing any issues should be completely acceptable. They already gave a large amount of their benefits in the design and verification process.</p>
<p>I hope you found this useful. If so I would love to hear your thoughts on the different types of testing.</p>
<h2 id="credits">Credits</h2>
<ul>
<li>Background photo by <a href="https://unsplash.com/@stijntestrake">Stijn te Strake</a></li>
<li>Social photo by <a href="https://unsplash.com/@tentides">Jeremy Bishop</a></li>
</ul>
</article><hr><nav class="pager"><ul class="pager-links"><li><a href="/page-module-model/" title="The Page Module Model with F# and Canopy">← Previous</a></li><li><a href="/functional-structural-impedance-mismatch/" title="The functional-structural impedance mismatch">Next →</a></li></ul></nav></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><div class="comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'devonburriss';(function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'https://devonburriss.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>