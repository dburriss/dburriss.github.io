<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>Better error handling</title><meta name="description" content="Part 3 of Designing clear method signatures"><meta name="author" content="Devon Burriss"><meta itemprop="name" content="Better error handling"><meta itemprop="description" content="Part 3 of Designing clear method signatures"><meta itemprop="image" content="https://devonburriss.me/img/explore-590.jpg"><link rel="canonical" href="https://devonburriss.me/better-error-handling/"><meta itemprop="datePublished" content="2017-03-19" id="date"><meta itemprop="dateModified" content="2017-03-19" id="mdate"><meta itemprop="headline" content="Better error handling - Part 3 of Designing clear method signatures"><meta itemprop="mainEntityOfPage" content="https://devonburriss.me/better-error-handling/"><meta name="headline" content="Better error handling - Part 3 of Designing clear method signatures"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="Better error handling"><meta name="twitter:description" content="Part 3 of Designing clear method signatures"><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/explore-590.jpg"><meta property="og:title" content="Better error handling"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/better-error-handling/"><meta property="og:image" content="https://devonburriss.me/img/explore-590.jpg"><meta property="og:description" content="Part 3 of Designing clear method signatures"><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script><script type="module" src="/js/search-ui.js"></script></head><body><header class="site-header"><nav class="site-nav"><a class="site-title nav-badge" href="/">DEVON BURRISS</a><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/notes/">Notes</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><span style="display:contents"><header class="page-header"><h1>Better error handling</h1><p class="page-subtitle">Part 3 of Designing clear method signatures</p><p class="post-meta">Devon Burriss &#183; Mar 19, 2017</p></header><div class="topic-pills"><a class="topic-pill" href="/topics/engineering-practices/" title="How we build, test, and validate software.">Engineering Practices</a><a class="topic-pill" href="/topics/platforms-runtime/" title="Runtimes and execution environments (not frameworks).">Platforms &amp; Runtime</a></div><hr></span><article class="prose"><p>In my <a href="/honest-return-types">previous post</a> I discussed handling <code>null</code> and <code>Exception</code> in the return type. In this post I will discuss returning logic errors.</p>
<h1 id="handling-errors">Handling errors</h1>
<p>There are times when valid errors can occur but are not exceptional. Validation is a common example of this and where a validation result is often the go to type. Wouldn't it be nice if we could apply the same pattern as with exceptions?</p>
<h2 id="either-errors-or-no-errors">Either: Errors or no errors</h2>
<p>Functional languages define a type with the following form: <code>Either&lt;Left, Right&gt;</code>. <code>Left</code> and <code>Right</code> can be anything but in the case of error handling <code>Left</code> is the unhappy path and <code>Right</code> is the happy path. Let's assume we have an <code>Error</code> type for representing errors that occurred, then using <code>Either</code> to represent error handling could look something like this: <code>Either&lt;IEnumerable&lt;Error&gt;, T&gt;</code>. <code>Error</code> has an implicit conversion to <code>string</code> so let's work with <code>string</code> for demonstration purposes below.</p>
<pre><code class="language-csharp">Func&lt;int, int, Either&lt;IEnumerable&lt;string&gt;, int&gt;&gt; divide =
    (i, d) =&gt;
    {
        if (d == 0)
            return List(&quot;Cannot divided by zero.&quot;);

        return (i / d);
    };

Either&lt;IEnumerable&lt;string&gt;, int&gt; divideByZeroResult = divide(1, 0);
divideByZeroResult.Match(
    Left: errors =&gt; errors.ToList().ForEach(x =&gt; Console.WriteLine(x)),
    Right: i =&gt; Console.WriteLine($&quot;Answer is {i}&quot;)
);
//Cannot divide by zero.

Either&lt;IEnumerable&lt;string&gt;, int&gt; twoResult = divide(4, 2);
twoResult.Match(
    Left: errors =&gt; errors.ToList().ForEach(x =&gt; Console.WriteLine(x)),
    Right: i =&gt; Console.WriteLine($&quot;Answer is {i}&quot;)
);
//Answer is 2
</code></pre>
<p>This works great but <code>Either&lt;IEnumerable&lt;string&gt;, int&gt;</code> is quite a verbose return type definition. If we know we are always going to use <code>IEnumerable&lt;string&gt;</code> as <code>Left</code> why not specify that in the type? Before we do that, we are going to take a quick dive into some functional programming ideas.</p>
<h2 id="functional-side-bar">Functional side-bar</h2>
<p>Lets go through a couple concepts that will come up. Hopefully you read the previous post that introduced <em>Elevated types</em>. Here I will quickly go through working with elevated types.</p>
<h3 id="return-to-the-world-of-elevated-types">Return: To the world of elevated types</h3>
<p><em>Return</em> is raising to the world of elevated types. You have already seen examples of return already in this post. <code>Some</code> and <code>None</code> for <code>Option&lt;T&gt;</code> and <code>Left</code> and <code>Right</code> for <code>Either&lt;L, R&gt;</code> are just some <em>return</em> operations.</p>
<pre><code class="language-csharp">//return - elevate an int to Option&lt;int&gt;
Option&lt;int&gt; optInt = Option&lt;int&gt;.Some(1);
// Some(1)
</code></pre>
<h3 id="apply-just-this-part">Apply - just this part</h3>
<p><em>Apply</em> unpacks a function and applies the first argument then returns an elevated function representing the result.</p>
<pre><code class="language-csharp">//apply
Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b;//function 
Option&lt;int&gt; addOpt = Some(add);//elevate function

var increment = addOpt.Apply(1) ;//apply: b =&gt; 1 + b
increment.Apply(5);
// Some(6)
</code></pre>
<h3 id="map-ol-switch-a-roo">Map: ol' switch-a-roo</h3>
<p><em>Map</em> applies the function to the value contained in the elevated value and returns the elevated result. In C# terms <em>Map</em> like LINQ's <code>Select</code>.</p>
<pre><code class="language-csharp">Func&lt;int, string&gt; intToString = (i) =&gt; i.ToString();
Option&lt;int&gt; optInt = Option&lt;int&gt;.Some(1);
//map - apply function to inner value
Option&lt;string&gt; optString = optInt.Map(intToString);
// Some(&quot;1&quot;)
</code></pre>
<h3 id="bind-functions-in-the-darkness">Bind: functions in the darkness</h3>
<blockquote>
<p>&ldquo;&hellip; and in the darkness bind them&rdquo;</p>
</blockquote>
<p>Sorry that was a Lord of the Rings reference. My 2nd name is legally Aragorn (from birth), I didn't stand a chance&hellip;<br />
<em>Bind</em> allows you to compose (bind) functions in an elevated world. It is analogous to <code>SelectMany</code> from LINQ fame.</p>
<pre><code class="language-csharp">Func&lt;string, Option&lt;int&gt;&gt; ifEvenInt = (s) =&gt;
{
    if (int.TryParse(s, out int i))
    {
        return (i % 2 == 0) ? Some(i) : None;
    }
    else
    {
        return None;
    }
};

Func&lt;int, Option&lt;int&gt;&gt; doubleIt = (i) =&gt; Some(i * 2);
Func&lt;int, Option&lt;int&gt;&gt; exp = (i) =&gt; Some(i * i);

Option&lt;string&gt; optString = optInt.Map(&quot;2&quot;);

//bind - passes inner value to a function that returns an elevated result
Option&lt;int&gt; eventResult = optString.Bind(ifEvenInt);
// used to combine elevated functions
var worked = eventResult
    .Bind(doubleIt)
    .Bind(exp);
// Some(16)
</code></pre>
<p>If we changed &ldquo;2&rdquo; to &ldquo;1&rdquo; the output would be <code>None</code> since <code>ifEvenInt</code> would return <code>None</code> which would short-circuit all the <code>Bind</code> calls.</p>
<h2 id="match-what-goes-up-must-come-down">Match: what goes up must come down</h2>
<p><em>Match</em> is the yin to <em>Return</em>'s yang. Where <em>Return</em> operations elevate values to the elevated world, <em>Match</em> drops an elevated value back to the real world.</p>
<pre><code class="language-csharp">//match
Option&lt;int&gt; optInt = Option&lt;int&gt;.Some(1);
optInt.Match(
    Some: x =&gt; Console.WriteLine(x),
    None: () =&gt; Console.WriteLine(&quot;Nothing&quot;)
);
// 1
</code></pre>
<p>Now that we can get to the elevated world, do what we need to do and then return back through the cupboard, let us get back to the business at hand. Validation!</p>
<h2 id="validation-your-result-might-have-errors">Validation: Your result (might have errors)</h2>
<blockquote>
<p>You can find the <code>Validation</code> type in <a href="https://github.com/dburriss/HonestTypes#return-types">HonestTypes.Returns</a> package</p>
</blockquote>
<p>So let's define a type <code>Validation&lt;T&gt;</code> that is <code>Either&lt;IEnumerable&lt;Error&gt;, T&gt;</code>? That would remove some of the verbosity of the return type as well as give a clearer semantic to the type name.</p>
<pre><code class="language-csharp">using static F;

public Validation&lt;Person&gt; Validate(Person person)
{
    if (person == null)
        return Error(&quot;Person is null&quot;);

    //short circuit on error
    return Valid(person)
        .Bind(ValidateFirstNames)
        .Bind(ValidateLastName)
        .Bind(ValidateEmail);
}

private Validation&lt;Person&gt; ValidateFirstNames(Person person)
{
    if (string.IsNullOrWhiteSpace(person.FirstNames))
        return Invalid(Error($&quot;{nameof(person.FirstNames)} cannot be empty&quot;));

    return person;
}

private Validation&lt;Person&gt; ValidateLastName(Person person)
{
    if (string.IsNullOrWhiteSpace(person.LastName))
        return Invalid(Error($&quot;{nameof(person.LastName)} cannot be empty&quot;));

    return person;
}

private Validation&lt;Person&gt; ValidateEmail(Person person)
{
    if (string.IsNullOrWhiteSpace((string)person.Email))
        return Invalid(Error($&quot;{nameof(person.Email)} cannot be empty&quot;));

    return person;
}

//usage
var validatedPerson = service.Validate(person);

validatedPerson.Match(
    Valid: p =&gt; Console.WriteLine($&quot;{p.LastName}, {p.FirstNames} &lt;{p.Email}&gt;&quot;),
    Invalid: err =&gt; err.ToList().ForEach(x =&gt; Console.WriteLine(x.Message))
);
</code></pre>
<p>The code above uses <code>Bind</code> and short-circuits on the first error. This might not be the desired behaviour. What if we want to check all validations? Here is a version that does that&hellip;</p>
<pre><code class="language-csharp">public Validation&lt;Person&gt; Validate(Person person)
{
    if (person == null)
        return Error(&quot;Person is null&quot;);

    //collect all errors
    return Valid(Person.Create)
        .Apply(ValidateFirstNames(person.FirstNames))
        .Apply(ValidateLastName(person.LastName))
        .Apply(ValidateEmail(person.Email));
}

Func&lt;FirstNames, Validation&lt;FirstNames&gt;&gt; ValidateFirstNames =&gt; firstNames =&gt;
{
    if (string.IsNullOrWhiteSpace(firstNames))
        return Invalid(Error($&quot;{nameof(firstNames)} cannot be empty&quot;));

    return firstNames;
};

Func&lt;LastName, Validation&lt;LastName&gt;&gt; ValidateLastName =&gt; lastName =&gt;
{
    if (string.IsNullOrWhiteSpace(lastName))
        return Invalid(Error($&quot;{nameof(lastName)} cannot be empty&quot;));

    return lastName;
};

Func&lt;Email, Validation&lt;Email&gt;&gt; ValidateEmail =&gt; email =&gt;
{
    if (string.IsNullOrWhiteSpace((string)email))
        return Invalid(Error($&quot;{nameof(email)} cannot be empty&quot;));

    return email;
};
</code></pre>
<p>The above code uses <code>Apply</code> and is applicative so all errors are returned. Notice how the return result is actually a <code>Func</code> that performs the validation.</p>
<p>if you don't like the <code>Func</code> style you can continue to use the <code>Bind</code> syntax but with the applicative nature using <code>Validation</code> types <code>Join</code> method&hellip;</p>
<pre><code class="language-csharp">//collect all errors
return Valid(person)
    .Join(ValidateFirstNames(person))
    .Join(ValidateLastName(person))
    .Join(ValidateEmail(person));
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>And there you have some neat validation logic. If you have any comments or suggestions please leave them below. If you found this useful, please share it with someone who you think might also find it useful.</p>
<h2 id="recommended-reading">Recommended Reading</h2>
<ol>
<li><a href="https://fsharpforfunandprofit.com/posts/elevated-world/">Elevated world</a></li>
<li><a href="https://fsharpforfunandprofit.com/rop/">Railway oriented programming</a></li>
</ol>
</article><hr><nav class="pager"><ul class="pager-links"><li><a href="/honest-return-types/" title="Honest Return Types">← Previous</a></li><li><a href="/check-in-check-out/" title="Check-in and Check-out">Next →</a></li></ul></nav></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><div class="comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'devonburriss';(function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'https://devonburriss.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>