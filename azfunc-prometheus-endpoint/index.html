<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="dark light"><title>Capturing custom business metrics in Azure Functions</title><meta name="description" content="A simple example showing how to expose a Prometheus endpoint from Azure Functions using the Fennel library"><meta name="author" content="Devon Burriss"><meta itemprop="name" content="Capturing custom business metrics in Azure Functions"><meta itemprop="description" content="A simple example showing how to expose a Prometheus endpoint from Azure Functions using the Fennel library"><meta itemprop="image" content="https://devonburriss.me/img/posts/2020/flame-500.jpg"><link rel="icon" type="image/png" href="/img/favicon16.png" sizes="16x16"><link rel="icon" type="image/png" href="/img/favicon32.png" sizes="32x32"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@DevonBurriss"><meta name="twitter:title" content="Capturing custom business metrics in Azure Functions"><meta name="twitter:description" content="A simple example showing how to expose a Prometheus endpoint from Azure Functions using the Fennel library"><meta name="twitter:creator" content="@DevonBurriss"><meta name="twitter:image" content="https://devonburriss.me/img/posts/2020/flame-500.jpg"><meta property="og:title" content="Capturing custom business metrics in Azure Functions"><meta property="og:type" content="article"><meta property="og:url" content="https://devonburriss.me/azfunc-prometheus-endpoint/"><meta property="og:image" content="https://devonburriss.me/img/posts/2020/flame-500.jpg"><meta property="og:description" content="A simple example showing how to expose a Prometheus endpoint from Azure Functions using the Fennel library"><meta property="og:site_name" content="Devon Burriss&#39; Blog"><link rel="stylesheet" href="/css/site.css"><link rel="stylesheet" href="/css/highlight/atom-one-dark.css"><script>(function(){try{var t=localStorage.getItem('theme');if(t==='dark'||t==='light'){document.documentElement.dataset.theme=t;}}catch(e){}})();</script><script src="/js/theme.js" defer="defer"></script><script type="module" src="/js/search-ui.js"></script></head><body><header class="site-header"><nav class="site-nav"><a class="site-title nav-badge" href="/">DEVON BURRISS</a><ul class="site-links"><li><a href="/">Home</a></li><li><a href="/topics/">Topics</a></li><li><a href="/notes/">Notes</a></li><li><a href="/recommended-reading.html">Reading</a></li><li><a href="/about/">About</a></li><li><a href="/rss.xml">RSS</a></li></ul><button type="button" class="theme-toggle" id="theme-toggle" aria-label="Toggle light/dark theme">Theme</button></nav></header><main class="site-main"><span style="display:contents"><header class="page-header"><h1>Capturing custom business metrics in Azure Functions</h1><p class="page-subtitle">A Proof-of-concept for scraping Prometheus metrics from Azure Functions</p><p class="post-meta">Devon Burriss</p></header><div class="topic-pills"><a class="topic-pill" href="/topics/platforms-runtime/" title="Runtimes and execution environments (not frameworks).">Platforms &amp; Runtime</a><a class="topic-pill" href="/topics/reliability-observability/" title="Monitoring, metrics, reliability, and failure modes.">Reliability &amp; Observability</a></div><hr></span><article class="prose"><p>For years now I have noticed a blind-spot when using serverless functions and observability platforms like Datadog. Custom metrics. Observability tools are constantly improving their integrations with cloud providers but are still not on par with having access to the OS like with VMs or containers. In this post I explore a little proof-of-concept I did to get custom metrics out of Azure Functions.</p>
<!--more-->
<h2 id="how-it-started">How it started</h2>
<p>A couple years back I explored solving this with a <a href="https://github.com/dburriss/DatadogAzureFunctions">custom binding</a> to Datadog but it was a naive implementation that just called Datadog's HTTP API. About a year ago I had the idea of scraping these metrics using Prometheus but at the time I couldn't find a library that easily allowed me to &ldquo;speak Promethean&rdquo;. The .NET libraries I found didn't seem to allow you to create or parse Prometheus logs, instead handling things from end-to-end. Usually as middleware.</p>
<h2 id="clearing-the-path">Clearing the path</h2>
<p>So about 7 months back I created a small library called <a href="https://github.com/dburriss/fennel">Fennel</a> which has a very simple purpose. Parse Prometheus text to objects, and turn these metric objects into valid Prometheus text. This gave me the building block I needed to easily try my experiment.</p>
<p>You can find my <a href="/prometheus-parser-fennel">post on Fennel here</a>.</p>
<h2 id="taking-the-steps">Taking the steps</h2>
<p><img src="../img/posts/2020/azfunc_prom_setup.jpg" alt="Design for scraping metrics from Azure Functions" /></p>
<p>So my idea is fairly simple. In any function that needs to emit metrics, use a Azure Function binding to write them to some store. I chose an Azure Storage Queue for simplicity but I need to post a disclaimer at this point:</p>
<blockquote>
<p>This is demo code hacked together in an evening and does not consider the following very important production quality points:</p>
<ol>
<li>Longer persistence of the metrics</li>
<li>Multiple consumers of the metrics</li>
<li>Enforcing ordering if more than 1 function instance is running</li>
<li>Resilience and sending custom metrics only if state has changed</li>
<li>This ignores a lot of the more complex things Prometheus exporters do</li>
</ol>
<p>The code will be available on my <a href="https://github.com/dburriss/Fennel.MetricsDemo">GitHub</a>.</p>
</blockquote>
<p>As a reminder, the Prometheus format is a text based format.</p>
<pre><code class="language-text"># This is a comment but the following 2 have meaning
# HELP http_requests_total The total number of HTTP requests.
# TYPE http_requests_total counter
http_requests_total{method=&quot;post&quot;,code=&quot;200&quot;} 1027 1395066363000
http_requests_total{method=&quot;post&quot;,code=&quot;400&quot;}    3 1395066363000
</code></pre>
<p>For this demo I have a small function on a timer trigger to emit metrics.</p>
<pre><code class="language-fsharp">// The builder ensures that a metric has HELP and TYPE information when written to a string
// For implementation: https://github.com/dburriss/Fennel.MetricsDemo/blob/master/Fennel.MetricsDemo/PrometheusLogBuilder.fs
let metricsBuilder = PrometheusLogBuilder()
                        .Define(&quot;sale_count&quot;, MetricType.Counter, &quot;Number of sales that have occurred.&quot;)

// Function for generating some simple metrics
[&lt;FunctionName(&quot;MetricsGenerator&quot;)&gt;]
let metricsGenerator([&lt;TimerTrigger(&quot;*/6 * * * * *&quot;)&gt;]myTimer: TimerInfo, [&lt;Queue(&quot;logs&quot;)&gt;] queue : ICollector&lt;string&gt;, log: ILogger) =
    let msg = sprintf &quot;Generating sales at: %A&quot; DateTime.Now
    log.LogInformation msg
    let sales = Random().Next(0, 50) |&gt; float
    let metric = Line.metric (MetricName &quot;demo_sale_count&quot;) (MetricValue.FloatValue sales) [] (Some(Timestamp DateTimeOffset.UtcNow))

    queue.Add(Line.asString metric)
    log.LogInformation (sprintf &quot;Sales : %f&quot; sales)
</code></pre>
<p>It places a Prometheus text representation of a <code>demo_sale_count</code> event on a queue called <code>logs</code>.</p>
<p>Next, I create a HTTP Azure Function to serve as the <code>/metrics</code> endpoint to be scraped by Prometheus.  It pulls the messages off the <code>logs</code> queue and builds up Prometheus text.</p>
<pre><code class="language-fsharp">[&lt;FunctionName(&quot;metrics&quot;)&gt;]
let metrics ([&lt;HttpTrigger(AuthorizationLevel.Anonymous, &quot;get&quot;, Route = null)&gt;]req: HttpRequest) (log: ILogger) =
    async {
        log.LogInformation(&quot;Fetching prometheus metrics...&quot;)
        // setup queue client
        let queueName = &quot;logs&quot;
        let connectionString = Environment.GetEnvironmentVariable(&quot;AzureWebJobsStorage&quot;, EnvironmentVariableTarget.Process)
        let queueClient = QueueClient(connectionString, queueName)
        
        if queueClient.Exists().Value then
            // receive messages
            let messages = queueClient.ReceiveMessages(Nullable&lt;int&gt;(32), Nullable&lt;TimeSpan&gt;(TimeSpan.FromSeconds(20.))).Value
            log.LogInformation(sprintf &quot;Received %i logs.&quot; messages.Length)
            // return message as text
            let processMessage (msg : QueueMessage) =
                let txt = Encoding.UTF8.GetString(Convert.FromBase64String(msg.MessageText))
                queueClient.DeleteMessage(msg.MessageId, msg.PopReceipt) |&gt; ignore
                txt
            let metrics = messages |&gt; Array.map processMessage
            // build up Prometheus text
            let responseTxt = metricsBuilder.Build(metrics)
            
            // return as Prometheus HTTP content
            let response = ContentResult()
            response.Content &lt;- responseTxt
            response.ContentType &lt;- &quot;text/plain; version=0.0.4&quot;
            response.StatusCode &lt;- Nullable&lt;int&gt;(200)
            return response :&gt; IActionResult
        else return NoContentResult() :&gt; IActionResult
        
    } |&gt; Async.StartAsTask
</code></pre>
<p>Nothing too interesting here other than the <code>ContentType</code> being &ldquo;text/plain; version=0.0.4&rdquo; as per Prometheus specification.</p>
<h2 id="how-its-going">How it's going</h2>
<p>Having the metrics endpoint up, all that is left is to <a href="/local-prometheus-setup">setup a local Prometheus instance</a> to call our Azure Function.</p>
<p>Looking at Prometheus' UI at <code>http://localhost:9090/graph</code> we can query for <code>sale_count</code> and we can see the metrics are coming in:</p>
<p><img src="../img/posts/2020/prometheus_sale_count.png" alt="Prometheus graph" /></p>
<p>At work we use Datadog and it turns out the <a href="https://www.datadoghq.com/blog/monitor-prometheus-metrics/">Datadog agent has support for scraping a Prometheus endpoint</a>. Once we have the <a href="/prometheus-datadog-agent">Datadog agent setup</a> we can see the metrics flowing into Datadog.</p>
<p><img src="../img/posts/2021/azurefunctiongraph.png" alt="Datadog metric from Prometheus" /></p>
<h2 id="conclusion">Conclusion</h2>
<p>This was a quick proof-of-concept of whether this approach was worth pursuing. I intend to take it further by running this in Azure and have a container with an agent reach out for metrics. It is unfortunate that the workarounds described here are necessary at this point but if we want a view on business metrics, we need to get creative. What I do like about this approach though is that it leverages Azure function bindings as well as Prometheus' scraping model, so not much had to be re-invented here. I am sure in the future we will see better baked in solutions for this but for now we work with what we have.</p>
<p><span>Photo by <a href="https://unsplash.com/@_ggleee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Gleb Lukomets</a> on <a href="https://unsplash.com/s/photos/flame?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span></p>
</article><hr><nav class="pager"><ul class="pager-links"><li><a href="/reliable-apis-part-1/" title="Reliable APIs - Part 1">← Previous</a></li><li><a href="/prometheus-datadog-agent/" title="Prometheus Datadog Agent">Next →</a></li></ul></nav></main><footer class="site-footer"><p>Copyright &#169; <a href="/about/">Devon Burriss</a> 2026</p></footer><div class="comments"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'devonburriss';(function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'https://devonburriss.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script src="/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-45750611-2', 'auto');ga('send', 'pageview');</script></body></html>